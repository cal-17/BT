
#include <mbed.h>
#include <ArduinoBLE.h>
#include <iostream>
#include <vector>
#include <queue>
#include <climits>

using namespace std;
using namespace rtos;
using namespace mbed;

bool forceStop = false;

//Bluetooth--------------------------------------------------------------------------
BLEService uartService("6E400001-B5A3-F393-E0A9-E50E24DCCA9E");  // Nordic UART Service (NUS)
BLECharacteristic txCharacteristic("6E400003-B5A3-F393-E0A9-E50E24DCCA9E", BLERead | BLENotify, 20);
BLECharacteristic rxCharacteristic("6E400002-B5A3-F393-E0A9-E50E24DCCA9E", BLEWrite, 20);

int PrintOutEnabled = 1;
int ExtendedEnabled = 1;

void PrintOut(String PrintOut, bool Extended) {  // Replacemnt print
  if (PrintOutEnabled) {
    if (Extended) {
      if (ExtendedEnabled) {
        Serial.print(PrintOut);

        txCharacteristic.writeValue(PrintOut.c_str());  // Send message via BLE
      }
    } else {
      Serial.print(PrintOut);

      txCharacteristic.writeValue(PrintOut.c_str());  // Buffer message for BLE
    }
  }
}

void PrintOutLn(String PrintOutLn, bool Extended) {
  if (PrintOutEnabled) {
    if (Extended) {
      if (ExtendedEnabled) {
        Serial.println(PrintOutLn);

        String messageWithNewline = PrintOutLn + "\n";  // Append newline for BLE consistency
        txCharacteristic.writeValue(messageWithNewline.c_str());
      }
    } else {
      Serial.println(PrintOutLn);

      String messageWithNewline = PrintOutLn + "\n";  // Append newline for BLE consistency
      txCharacteristic.writeValue(messageWithNewline.c_str());
    }
  }
}

//----------------------------------------------------------------------------------

//Thread----------------------------------------------------------------------------

Thread SensorsThread;  // Thread to continously update sensosrs
volatile bool runningSensors = true;

Thread MappingThread;  // Thread to continously update mapping
volatile bool runningMapping = true;

Thread distanceThread;  // Thread to continously check for grid movement updating the maze
volatile bool measureAvgDis = true;

//----------------------------------------------------------------------------------

//Sensors----------------------------------------------------------------------------
// I2C multiplexer and sensor addresses
#define MULTIPLEXER_ADDR 0xEE  // Multiplexer I2C address
#define SENSOR_ADDR 0x80       // Infrared sensor I2C address

// Sensor registers
#define DISTANCE_HIGH_REG 0x5E  // Register for high byte of distance data
#define SHIFT_BIT_REG 0x35      // Register for shift bit

// Multiplexer commands for selecting buses
#define MUX_BUS_0 0x01  // Bus 0
#define MUX_BUS_1 0x02  // Bus 1
#define MUX_BUS_2 0x04  // Bus 2
#define MUX_BUS_3 0x08  // Bus 3

// I2C pins for Nano 33 BLE (SCL and SDA)
#define SCL_PIN P0_31
#define SDA_PIN P0_2

// Instantiate the I2C object
I2C i2c(SCL_PIN, SDA_PIN);

#define US_PIN P0_23             // Define pin for both Trigger and Echo
DigitalInOut us_sensor(US_PIN);  // Use same pin for trigger and echo

void setMultiplexerBus(uint8_t busCommand);
float readDistanceCM();
void handleI2CError(int result);

// Distance floats
volatile float distance_F1;
volatile float distance_F2;
volatile float distance_R1;
volatile float distance_R2;
volatile float distance_L;

//Maze------------------------------------------------------------------------------
#define mazeWidth 35
#define mazeHeight 45


volatile float gridSize = 0.05;         // Grid size in meters
volatile float totalAvgDistance = 0.0;  // Total accumulated distance
int totalGridsMoved = 0;                // Count how many grids moved

int mazeMap[mazeHeight][mazeWidth];


// Robot's current position and direction
int robotX = 4;
int robotY = 40;
int robotDir = 1;  // 0= Up-North, 1= Right-East, 2= Down-South, 3= Left-West

const int finishCenterX = 16;  //4
const int finishCenterY = 11;  //10

// Robots Start and End
int startX = 4, startY = 40, endX = 2, endY = 2;

//  Robot Dimensions
const int robotWidth = 3;
const int robotHeight = 3;
//----------------------------------------------------------------------------------



//UltraSonic------------------------------------------------------------------------

void USDistance_L() {
  Timer timer;
  float duration;

  // Set pin as output to send trigger pulse
  us_sensor.output();
  us_sensor = 0;  // Ensure LOW before triggering
  wait_us(2);
  us_sensor = 1;  // Trigger pulse
  wait_us(10);
  us_sensor = 0;

  // Switch pin to input to read echo
  us_sensor.input();

  // Wait for echo HIGH with timeout
  int timeout = 30000;  // 30ms timeout
  while (us_sensor == 0 && timeout > 0) {
    wait_us(1);
    timeout--;
  }
  if (timeout <= 0) {
    Serial.println("Timeout waiting for echo HIGH");
    distance_L = -1.0f;  // Indicate failure
    return;
  }

  // Start timer when echo goes HIGH
  timer.start();

  // Wait for echo LOW with timeout
  timeout = 30000;  // Reset timeout
  while (us_sensor == 1 && timeout > 0) {
    wait_us(1);
    timeout--;
  }
  timer.stop();

  if (timeout <= 0) {
    Serial.println("Timeout waiting for echo LOW");
    distance_L = -1.0f;  // Indicate failure
    return;
  }

  // Get elapsed time in microseconds
  duration = timer.elapsed_time().count();

  // Calculate distance (speed of sound = 34300 cm/s)
  distance_L = (duration * 0.0343f) / 2.0f;

  // Subtract 1 cm from the measured distance
  distance_L -= 1.0f;  // Now distance_L is reduced by 1 cm
}

//IR--------------------------------------------------------------------------------

void handleI2CError(int result) {
  if (result != 0) {
    Serial.print("I2C Error: ");
    Serial.println(result);
  }
}

// Function to set the multiplexer to a specific bus
void setMultiplexerBus(uint8_t busCommand) {
  int result = i2c.write(MULTIPLEXER_ADDR, reinterpret_cast<char*>(&busCommand), 1);
  handleI2CError(result);
}

// Function to read and calculate the distance in cm
float readDistanceCM() {
  char cmd;                 // Command for register access
  char rawData[2] = { 0 };  // Array to store raw sensor data
  char shiftBit = 0;        // Shift bit for scaling

  // Step 1: Read the shift bit from the sensor
  cmd = SHIFT_BIT_REG;
  i2c.write(SENSOR_ADDR, &cmd, 1);
  ThisThread::sleep_for(10ms);  // Allow the sensor time to process the command

  i2c.read(SENSOR_ADDR, &shiftBit, 1);

  // Step 2: Read the raw distance data (2 bytes)
  cmd = DISTANCE_HIGH_REG;
  i2c.write(SENSOR_ADDR, &cmd, 1);

  ThisThread::sleep_for(10ms);

  i2c.read(SENSOR_ADDR, rawData, 2);

  // Step 3: Combine high and low bytes into a single value
  uint16_t distance_R2aw = (rawData[0] << 8) | rawData[1];  // (rawData[0]*16 + rawData[1])/16/pow(2,2)

  // Step 4: Calculate the distance in cm using the shift bit
  float distanceCM = (rawData[0] * 16 + rawData[1]) / 16 / pow(2, 2);  //distance_R2aw / pow(2, shiftBit);

  return distanceCM;
}

// Sensors Thread cycles tough updating each sensor
void checksensors() {
  while (runningSensors) {
    setMultiplexerBus(MUX_BUS_0);
    distance_F1 = readDistanceCM();

    setMultiplexerBus(MUX_BUS_1);
    distance_F2 = readDistanceCM();

    setMultiplexerBus(MUX_BUS_2);
    distance_R1 = readDistanceCM();

    setMultiplexerBus(MUX_BUS_3);
    distance_R2 = readDistanceCM();

    USDistance_L();
  }
}

// Command to give print outs of sensor readings
void checksensorscheck() {
  PrintOutLn("Front Sensors: ", false);
  PrintOutLn("F1: " + String(distance_F1) + " | F2: " + String(distance_F2), false);

  PrintOutLn("Right Sensors: ", false);
  PrintOutLn("R1: " + String(distance_R1) + " | R2: " + String(distance_R2), false);

  PrintOutLn("Left Sensor: ", false);
  PrintOutLn("L: " + String(distance_L) + " cm", false);
}
//----------------------------------------------------------------------------------

//Motors----------------------------------------------------------------------------
// Define PWM pins for the motors
PwmOut motorA_pwm(P1_2);   // Motor 1 PWM pin
PwmOut motorB_pwm(P0_27);  // Motor 2 PWM pin

// Define direction control pins for the motors
DigitalOut motorA_dir(P0_4);  // Motor 1 direction pin
DigitalOut motorB_dir(P0_5);  // Motor 2 direction pin

// Define Encoder pins for Motor A and Motor B
InterruptIn encoderA(P1_12);
InterruptIn encoderB(P1_11);

// bool to make sure the average distance thread does not update when turning
bool TurnCheck = false;

// Define motor speed (between 0.0 and 1.0)
volatile float motor_speed = 0.0;

// Encoder variables for Motor A and Motor B
volatile int pulseCountA = 0;
volatile int pulseCountB = 0;
volatile int pulseCountDisA = 0;
volatile int pulseCountDisB = 0;
volatile int pulseCountA2 = 0;
volatile int pulseCountB2 = 0;
volatile int pulseCountDisA2 = 0;
volatile int pulseCountDisB2 = 0;
volatile float motorSpeedA = 0.0;      // Motor A speed
volatile float motorSpeedB = 0.0;      // Motor B speed
volatile float motorSpeedReadA = 0.0;  // Motor A speed measured in RPM
volatile float motorSpeedReadB = 0.0;  // Motor B speed measured in RPM

// Total distance traveled by each motor
volatile float distanceA = 0.0;
volatile float distanceB = 0.0;
volatile float distanceA2 = 0.0;  //Finishgrid
volatile float distanceB2 = 0.0;  //Finishgrid

volatile float avgDistance = (distanceA + distanceB) / 2.0;
volatile float avgDistance2 = (distanceA2 + distanceB2) / 2.0;


// Encoder pulses per revolution (adjust to match your encoder's spec)
volatile float pulsesPerRevolutionA = 330.0;  // Motor A encoder PPR
volatile float pulsesPerRevolutionB = 330.0;  // Motor B encoder PPR

// Wheel parameters
volatile float turningCircle = 0.292;                                          // in m
volatile float wheelDiameter = 0.0475;                                         // Example wheel diameter in meters (4.75 cm)
volatile float wheelCircumference = 3.14159 * wheelDiameter;                   // Circumference of the wheel
volatile float distancePerPulseA = wheelCircumference / pulsesPerRevolutionA;  // Distance per pulse for Motor A
volatile float distancePerPulseB = wheelCircumference / pulsesPerRevolutionB;  // Distance per pulse for Motor B

volatile int Equalized = 0;

Timer speedTimer;  // Timer to calculate motor speed every second

// Interrupt handler for encoder A (Motor A)
void encoderISR_A() {
  pulseCountA++;
  pulseCountDisA++;
  pulseCountDisA2++;
}

// Interrupt handler for encoder B (Motor B)
void encoderISR_B() {
  pulseCountB++;
  pulseCountDisB++;
  pulseCountDisB2++;
}

void forward() {  // Sets motors to forward
  motorA_dir = 1;
  motorB_dir = 0;
  Serial.println("Motors set to forward.");
}

void reverse() {  // Sets motors to reverse
  motorA_dir = 0;
  motorB_dir = 1;
  Serial.println("Motors set to reverse.");
}

void left() {  // Sets motors to left
  motorA_dir = 1;
  motorB_dir = 1;
  Serial.println("Motors set to left turn");
}

void right() {  // Sets motors to right
  motorA_dir = 0;
  motorB_dir = 0;
  Serial.println("Motors set to right turn");
}

void brake() {  // Sets motor speeds to 0(stop)
  motorA_pwm.write(0);
  motorB_pwm.write(0);
  PrintOutLn("Motors stop", false);
}

void DistanceA() {
  distanceA = pulseCountDisA * distancePerPulseA;    // Distance for Motor A
  distanceA2 = pulseCountDisA2 * distancePerPulseA;  // finsihgridspace
}

void DistanceB() {
  distanceB = pulseCountDisB * distancePerPulseB;    // Distance for Motor B
  distanceB2 = pulseCountDisB2 * distancePerPulseB;  // finsihgridspace
}

void reset() {  // Resets motor distance traveled
  brake();
  distanceA = 0.0;
  distanceB = 0.0;
  pulseCountDisA = 0;
  pulseCountDisB = 0;
}

void equalizeMotor() {
  Equalized = 0;  // Reset the equalization flag

  while (Equalized == 0) {
    // Calculate RPM
    motorSpeedReadA = (pulseCountA / pulsesPerRevolutionA);
    motorSpeedReadB = (pulseCountB / pulsesPerRevolutionB);

    pulseCountA = 0;
    pulseCountB = 0;

    float diff = motorSpeedReadB - motorSpeedReadA;

    if (diff > 3) {
      motorSpeedB = max(motorSpeedB - 0.01, 0.0);  // Decrease Motor B speed
      Serial.print(motorSpeedReadB);
      Serial.print(" > ");
      Serial.print(motorSpeedReadA);
      Serial.print(" by ");
      Serial.print(diff);
      Serial.print(" Decrementing B to ");
      Serial.println(motorSpeedB);
    }
    if (diff < -3) {
      motorSpeedA = max(motorSpeedA - 0.01, 0.0);  // Decrease Motor A speed
      Serial.print(motorSpeedReadB);
      Serial.print(" < ");
      Serial.print(motorSpeedReadA);
      Serial.print(" by ");
      Serial.print(diff);
      Serial.print(" Decrementing A to ");
      Serial.println(motorSpeedA);
    }

    motorA_pwm.write(motorSpeedA);
    motorB_pwm.write(motorSpeedB);

    // PrintOutging output
    Serial.print("Motor A RPM: ");
    Serial.println(motorSpeedReadA);
    Serial.print("Motor B RPM: ");
    Serial.println(motorSpeedReadB);
    Serial.print("Difference in RPM: ");
    Serial.println(diff);
    Serial.print("PWM A: ");
    Serial.println(motorSpeedA);
    Serial.print("PWM B: ");
    Serial.println(motorSpeedB);
    Serial.print("RPM A: ");
    Serial.println(motorSpeedReadA);
    Serial.print("RPM B: ");
    Serial.println(motorSpeedReadB);

    ThisThread::sleep_for(50ms);  // Adjust based on encoder response time

    // Check if RPMs are within ±3
    if (abs(motorSpeedReadA - motorSpeedReadB) <= 3) {
      Equalized = 1;
      Serial.println("Motors successfully equalized.");
    }
  }
}

// Thread that checks for forward grid space movement updating the robots position
void measureAverageDistance() {
  while (measureAvgDis) {
    ThisThread::sleep_for(10ms);

    //    Serial.println("In while");
    if (TurnCheck == false) {  // Only measure distance when not turning


      DistanceA();  // Reset distance for Motor A
      DistanceB();  // Reset distance for Motor B

      float avgDistance = (distanceA + distanceB) / 2.0;  // Calculated average distance

      totalAvgDistance += avgDistance;  // Totalled average distance


      //Serial.print("avgDistance: ");
      //Serial.println(avgDistance);


      if (avgDistance >= gridSize) {  // Travel Grid distance
        //PrintOutLn("In avgDistanceIf", false);
        //PrintOut("avgDistance: ", false);
        //PrintOutLn(String(avgDistance), false);
        //PrintOut("gridSize: ", false);
        //PrintOutLn(String(gridSize), false);
        // Update position
        robotX += dx(robotDir);
        robotY += dy(robotDir);
        totalGridsMoved++;
        /*Serial.println("Updated Position:");
        Serial.print("X: ");
        Serial.print(robotX);
        Serial.print(" Y: ");
        Serial.println(robotY);

        Serial.print("Total Grids Moved: ");
        Serial.println(totalGridsMoved);

        Serial.print("Motor A distance: ");
        Serial.print(distanceA * 100);
        Serial.println(" cm");
        Serial.print("Motor B distance: ");
        Serial.print(distanceB * 100);
        Serial.println(" cm");
        Serial.print("Distance Travelled A and B ");
        Serial.print(avgDistance * 100);
        Serial.println("cm");*/


        // Reset distances
        pulseCountDisA = 0;
        pulseCountDisB = 0;
        distanceA = 0;
        distanceB = 0;
      }
    }
    ThisThread::sleep_for(10ms);
  }
}

//Turning Functions-----------------------------------------------------------------

bool dontAlign;  // Bool to stop align from running if a wall ahead only coverse one sensor

void alignFront() {  //Function to align front making use of trig to calculate the required angle
  if (dontAlign == false) {
    Serial.print("Sensor F1 Distance: ");
    Serial.print(distance_F1);
    Serial.print(" cm | ");
    Serial.print("Sensor F2 Distance: ");
    Serial.print(distance_F2);
    Serial.println(" cm");

    PrintOutLn("Align Front", false);
    //PrintOutLn(String(distance_F1), false);
    //PrintOut("Sensor F2 Distance: ", false);
    //PrintOutLn(String(distance_F2), false);


    if (distance_F1 > distance_F2) {
      volatile float TurnAngle = (atan2(distance_F1 - distance_F2, 9) * (180.0 / PI));
      PrintOut("Calculated Angle: ", false);
      PrintOutLn(String(TurnAngle), false);
      if ((TurnAngle > 5) && (TurnAngle < 10)) {
        //TurnRightAngle(TurnAngle);
      } else if (TurnAngle >= 10) {
        // PrintOut("Greater than 10 ", false);
        TurnAngle = TurnAngle * 1;
        // PrintOut("Angle: ", false);
        // PrintOutLn(String(TurnAngle), false);
        TurnRightAngle(TurnAngle);
      } else {
        brake();
        PrintOut("Angle To Small", false);
      }
    } else if (distance_F1 < distance_F2) {
      volatile float TurnAngle = (atan2(distance_F2 - distance_F1, 9) * (180.0 / PI));
      // PrintOut("Calculated Angle: ", false);
      // PrintOutLn(String(TurnAngle), false);
      if (TurnAngle > 5) {
        // TurnLeftAngle(TurnAngle);
      } else if (TurnAngle >= 10) {
        // PrintOut("Greater than 10 ", false);
        TurnAngle = TurnAngle * 1.07;
        // PrintOut("Angle: ", false);
        // PrintOutLn(String(TurnAngle), false);
        TurnLeftAngle(TurnAngle);
      } else {
        brake();
        PrintOut("Angle To Small", false);
      }
    } else {  // If both distances are equal
      Serial.println("Already Aligned, No Turn Needed");
    }
  }
}

void TurnLeftAngle(float TurnAngle) {  // Turns Angle into distance
  PrintOut("Align Left", false);
  TurnCheck = true;

  float turningDistance = ((abs(TurnAngle) / 360.0) * turningCircle);  // Calculated distnace to turn required angle
  PrintOut("Turinig Distance: ", false);
  PrintOutLn(String(turningDistance * 100), false);

  // Reset encoders
  pulseCountDisA = 0;
  pulseCountDisB = 0;
  distanceA = 0;
  distanceB = 0;

  motorSpeedA = 0.3;
  motorSpeedB = 0.3 + 0.0417;

  left();
  equalizeMotor();

  DistanceA();  // Reset distance for Motor A
  DistanceB();  // Reset distance for Motor B

  // Move until the robot has turned the required angle
  while (distanceA < turningDistance && distanceB < turningDistance) {
    DistanceA();  // Update the distance for Motor A
    DistanceB();  // Update the distance for Motor B

    Serial.print("Motor A distance: ");
    Serial.print(distanceA * 100);
    Serial.println(" cm");
    Serial.print("Motor B distance: ");
    Serial.print(distanceB * 100);
    Serial.println(" cm");
  }

  Serial.print("Sensor F1 Distance: ");
  Serial.print(distance_F1);
  Serial.print(" cm | ");
  Serial.print("Sensor F2 Distance: ");
  Serial.print(distance_F2);
  Serial.println(" cm");

  checksensorscheck();

  // Stop the motors after reaching the turning target
  reset();
  brake();
  Serial.println("Left Turn Completed");
}

void TurnRightAngle(float TurnAngle) {  // Turns Angle into distance
  PrintOut("Align Right", false);
  TurnCheck = true;
  PrintOut("Angle: ", false);
  PrintOutLn(String(TurnAngle), false);

  float turningDistance = ((abs(TurnAngle) / 360.0) * turningCircle);  // Calculated distnace to turn required angle
  PrintOut("Turinig Distance: ", false);
  PrintOutLn(String(turningDistance * 100), false);

  // Reset
  pulseCountDisA = 0;
  pulseCountDisB = 0;
  distanceA = 0;
  distanceB = 0;

  motorSpeedA = 0.3;
  motorSpeedB = 0.3 + 0.0417;

  right();
  equalizeMotor();

  // Reset pulse counts
  pulseCountA = 0;
  pulseCountB = 0;

  DistanceA();  // Reset distance for Motor A
  DistanceB();  // Reset distance for Motor B

  // Move until the robot has turned the required angle
  while (distanceA < turningDistance && distanceB < turningDistance) {
    DistanceA();  // Update the distance for Motor A
    DistanceB();  // Update the distance for Motor B

    Serial.print("Motor A distance: ");
    Serial.print(distanceA * 100);
    Serial.println(" cm");
    Serial.print("Motor B distance: ");
    Serial.print(distanceB * 100);
    Serial.println(" cm");
  }

  Serial.print("Sensor F1 Distance: ");
  Serial.print(distance_F1);
  Serial.print(" cm | ");
  Serial.print("Sensor F1 Distance: ");
  Serial.print(distance_F1);
  Serial.println(" cm");

  checksensorscheck();

  // Stop the motors after reaching the turning target
  reset();
  brake();
  Serial.println("Left Turn Completed");
}

void turnninetyleft() {
  PrintOut("Left Turn", false);
  TurnCheck = true;

  left();  // Set the motors to left

  // Reset
  pulseCountDisA = 0;
  pulseCountDisB = 0;
  distanceA = 0;
  distanceB = 0;

  motorSpeedA = 0.3;
  motorSpeedB = 0.3 + 0.0417;

  equalizeMotor();

  DistanceA();  // Update the distance for Motor A
  DistanceB();  // Update the distance for Motor B

  while (distanceA < 0.072 && distanceB < 0.072) {
    DistanceA();  // Update the distance for Motor A
    DistanceB();  // Update the distance for Motor B

    Serial.print("Motor A distance: ");
    Serial.print(distanceA * 100);
    Serial.println(" cm");
    Serial.print("Motor B distance: ");
    Serial.print(distanceB * 100);
    Serial.println(" cm");
  }

  brake();

  robotDir = (robotDir - 1 + 4) % 4;  // Update direction by -1 (mod 4)
  TurnCheck = false;
  Serial.println("Turned Left 90");
  reset();
  ThisThread::sleep_for(10ms);
}

void turnninetyright() {
  PrintOut("Right Turn", false);
  TurnCheck = true;

  right();  // Set the motors right

  // Reset
  pulseCountDisA = 0;
  pulseCountDisB = 0;
  distanceA = 0;
  distanceB = 0;

  motorSpeedA = 0.3;
  motorSpeedB = 0.3 + 0.0417;

  equalizeMotor();

  DistanceA();  // Update the distance for Motor A
  DistanceB();  // Update the distance for Motor B

  while (distanceA < 0.0723 && distanceB < 0.0723) {
    DistanceA();  // Update the distance for Motor A
    DistanceB();  // Update the distance for Motor B

    Serial.print("Motor A distance: ");
    Serial.print(distanceA * 100);
    Serial.println(" cm");
    Serial.print("Motor B distance: ");
    Serial.print(distanceB * 100);
    Serial.println(" cm");
  }

  brake();

  robotDir = (robotDir + 1) % 4;  // Update direction by +1 (mod 4)
  TurnCheck = false;
  Serial.println("Turned Right 90");
  reset();
  ThisThread::sleep_for(10ms);
}


//Movement Functions----------------------------------------------------------------

void moveBack() {  // Move back one grid space
  TurnCheck = false;

  pulseCountDisA = 0;
  pulseCountDisB = 0;

  // Start moving the robot
  reverse();

  motorSpeedA = 0.3;
  motorSpeedB = 0.3;
  equalizeMotor();

  DistanceA();
  DistanceB();

  while (distanceA < gridSize && distanceB < gridSize) {
    DistanceA();  // Update the distance for Motor A
    DistanceB();  // Update the distance for Motor B

    // PrintOutging information (optional)
    Serial.print("Motor A distance: ");
    Serial.print(distanceA * 100);  // Convert to cm
    Serial.println(" cm");
    Serial.print("Motor B distance: ");
    Serial.print(distanceB * 100);  // Convert to cm
    Serial.println(" cm");
  }

  // Stop the motors after moving the grid size
  brake();
  reset();

  Serial.println("Stopped after moving 5 cm (1 grid cell)");

  ThisThread::sleep_for(50ms);
}
/*
void moveForward(int numCells) {  // Move forward given number of grids
  //float gridSize = 0.05;                       // 5 cm per grid cell (in meters)
  //float targetDistance = numCells * gridSize;  // Total distance to move (in meters)
  TurnCheck = false;

  int gridsMoved = 0;
  float totalAverageDistanceTravelled = 0.0;
  float previousAverageDistance = 0.0;  // Stores last loop's average distance

  // Reset pulse counts and distance for both motors
  pulseCountDisA = 0;
  pulseCountDisB = 0;
  distanceA = 0;
  distanceB = 0;

  // Start moving forward
  forward();
  motorSpeedA = 0.3;
  motorSpeedB = 0.3;
  equalizeMotor();

  DistanceA();
  DistanceB();

  while (gridsMoved < numCells) {
    // Calculate the current average distance
    DistanceA();
    DistanceB();    
    avgDistance = (distanceA + distanceB) / 2.0;


    // Add to total distance travelled
    totalAverageDistanceTravelled += (avgDistance - previousAverageDistance);

    // Detect if the distance was reset (suggesting a grid was traversed)
    if (avgDistance >= gridSize) {
      gridsMoved++;
      Serial.print("Grid spaces moved: ");
      Serial.println(gridsMoved);
    }
    Serial.print("Motor A distance: ");
    Serial.print(distanceA * 100);  // Convert to cm
    Serial.println(" cm");
    Serial.print("Motor B distance: ");
    Serial.print(distanceB * 100);  // Convert to cm
    Serial.println(" cm");

    // Update previous distance for next loop iteration
    previousAverageDistance = avgDistance;

    // Stop early if an obstacle is detected
    if (wallAhead()) {
      brake();
      checksensorscheck();
      Serial.println("Obstacle detected! Stopping.");
      Serial.print("Total average distance travelled (cm): ");
      Serial.println(totalAverageDistanceTravelled * 100);
      return;
    }
  }

  // Stop the motors after moving the required grid spaces
  brake();
  reset();
  Serial.println("Reached target distance. Stopping.");

  // Print total distance traveled
  Serial.print("Final total average distance travelled: ");
  Serial.println(totalAverageDistanceTravelled * 100);
  ThisThread::sleep_for(20ms);
}*/

void moveForward(int numCells) {
  PrintOut("Moving Forward: ", false);
  PrintOutLn(String(numCells), false);
  TurnCheck = false;
  int startGridCount = totalGridsMoved;  // Get current grid count
  const float baseSpeed = 0.3;           // Base motor speed

  // Start moving forward
  forward();
  motorSpeedB = baseSpeed + 0.0417;
  motorSpeedA = baseSpeed;
  equalizeMotor();

  //while (!(robotX >= finishCenterX - 2 && robotX <= finishCenterX + 2 && robotY >= finishCenterY - 2 && robotY <= finishCenterY + 2)) {
  //PrintOutLn("In While Forward", false);

  while (totalGridsMoved < startGridCount + numCells) {
    //  PrintOut(String("totalGridsMoved: "), false);
    // PrintOutLn(String(totalGridsMoved), false);
    // PrintOut(String("startGridCount: "), false);

    //PrintOutLn(String(startGridCount), false);
    // PrintOut(String("numCells: "), false);

    //PrintOutLn(String(numCells), false);
    //PrintOutLn("In while Forward", false);

    if (wallAhead()) {
      //PrintOutLn("In If Forward", false);
      brake();
      checksensorscheck();
      finishGridSpace();
      alignFront();
      PrintOutLn("Obstacle detected", false);
      break;
    }
    if ((robotX >= finishCenterX - 5 && robotX <= finishCenterX + 5 && robotY >= finishCenterY - 3 && robotY <= finishCenterY + 5)) {
      //PrintOutLn("In If Finish", false);
      brake();
      checksensorscheck();
      //PrintOutLn("Obstacle detected", false);
      break;
    }
    ThisThread::sleep_for(5ms);  // Allow thread time to update totalGridsMoved
  }
  //}
  // Stop motors when done
  brake();
  PrintOut("Reached target distance.", false);
}


void maintainDistancefromRightWall() {  //Maintain Right distance from Wall as traveling
  PrintOut("Maintain Right", false);
  const float gridSizeCm = 5.0;                                             // Grid size in cm
  const float distanceTolerance = 0.035;                                    // Tolerance for maintaining distance
  const float adjustment = 0.04;                                            // Adjustment increment for motors
  const float baseSpeed = 0.3;                                              // Base motor speed
  float avgRightDistance = (distance_R1 + distance_R2) / 2.0;               // Average right distance
  float targetDistance = ceil(avgRightDistance / gridSizeCm) * gridSizeCm;  // Round up to nearest 5 cm

  // Reset pulse counts and distances
  pulseCountDisA = 0;
  pulseCountDisB = 0;
  distanceA = 0;
  distanceB = 0;

  forward();
  equalizeMotor();  // Balance the motors before starting control
  TurnCheck = false;

  while (!(robotX >= finishCenterX - 5 && robotX <= finishCenterX + 5 && robotY >= finishCenterY - 3 && robotY <= finishCenterY + 5)) {
    //PrintOut("Sensor R1 Distance: ", false);
    // PrintOutLn(String(distance_R1), false);
    //PrintOut("Sensor R2 Distance: ", false);
    //PrintOutLn(String(distance_R2), false);

    //PrintOut("Target Distance: ", false);
    //PrintOutLn(String(targetDistance), false);

    if (targetDistance > 10.0) {
      targetDistance = 10.0;
      PrintOutLn("Target distance capped at 10.", false);
    }

    // Default motor speeds
    motorSpeedB = baseSpeed + 0.0417;
    motorSpeedA = baseSpeed;

    //equalizeMotor();  // Balance the motors before starting control


    /*// --- Maintain Distance from Right Wall ---
    if (distance_R1 > targetDistance + distanceTolerance && distance_R2 > targetDistance + distanceTolerance) {
      motorSpeedA = baseSpeed + adjustment;
      motorSpeedB = baseSpeed + 0.0417;
      Serial.println("Moving Closer to Wall");
    } else if (distance_R1 < targetDistance - distanceTolerance && distance_R2 < targetDistance - distanceTolerance) {
      motorSpeedA = baseSpeed;
      motorSpeedB = baseSpeed + adjustment + 0.0417;
      Serial.println("Moving Away from Wall");
    } else if (distance_R1 > targetDistance + distanceTolerance && distance_R2 < targetDistance - distanceTolerance) {
      motorSpeedA = baseSpeed + adjustment;
      motorSpeedB = baseSpeed + 0.0417;
      Serial.println("Rotating Clockwise to Align");
    } else if (distance_R1 < targetDistance - distanceTolerance && distance_R2 > targetDistance + distanceTolerance) {
      motorSpeedA = baseSpeed;
      motorSpeedB = baseSpeed + adjustment + 0.0417;
      Serial.println("Rotating Counterclockwise to Align");
    } else {
      motorSpeedA = baseSpeed;
      motorSpeedB = baseSpeed + 0.0417;
      Serial.println("Maintaining Distance from Wall");
    }*/

    // --- Obstacle Detection and Stop Condition ---
    if (wallAhead()) {
      brake();
      checksensorscheck();
      finishGridSpace();
      alignFront();
      PrintOutLn("Obstacle detected", false);
      break;
    }
    if (gapOnRight()) {
      brake();
      checksensorscheck();
      finishGridSpace();
      PrintOutLn("Obstacle detected", false);
      break;
    }
    //PrintOut("Grids Moved: ", false);
    //PrintOutLn(String(totalGridsMoved), false);

    //PrintOut("Total Distance Moved: ", false);
    //PrintOutLn(String(totalAvgDistance), false);

    // PrintOutging output for motor speeds
    Serial.print("Motor Speed A: ");
    Serial.print(motorSpeedA);
    Serial.print(" | Motor Speed B: ");
    Serial.println(motorSpeedB);
    motorA_pwm.write(motorSpeedA);
    motorB_pwm.write(motorSpeedB);
    //PrintOutLn("End of loop", false);
  }
  PrintOutLn("End of Maintain", false);
  brake();

  ThisThread::sleep_for(10ms);  // Non-blocking sleep for
}

/*void stopCommand() {
  forceStop = true;
  ThisThread::sleep_for(20ms);
  forceStop = false;
}*/

void finishGridSpace() {                // Completes a gridspace to allow for accurate positioning
  const float targetDistance = 5.0;     // 5 cm for one grid space
  const float distanceTolerance = 0.2;  // Tolerance for completion (in cm)
  const float baseSpeed = 0.3;          // Base motor speed
  TurnCheck = false;

  pulseCountDisA2 = 0;
  pulseCountDisB2 = 0;
  distanceA2 = 0;
  distanceB2 = 0;

  float avgDistance = (distanceA + distanceB) / 2.0;
  float remainingDistance = targetDistance - avgDistance;  // Remaining distance to cover

  const float remainingdistanceA = distanceA;
  const float remainingdistanceB = distanceB;

  //PrintOut("avgDis: ", false);
  //PrintOutLn(String(avgDistance), false);
  //PrintOut("DistanceA: ", false);
  //PrintOutLn(String(distanceA), false);
  //PrintOut("DistanceB: ", false);
  //PrintOutLn(String(distanceB), false);
  Serial.print("Motor A distance: ");
  Serial.print(distanceA * 100);
  Serial.println(" cm");
  Serial.print("Motor B distance: ");
  Serial.print(distanceB * 100);
  Serial.println(" cm");


  forward();  // Set motors to forward
  equalizeMotor();


  // If the robot is already within tolerance of the target distance
  if (remainingDistance <= distanceTolerance) {
    PrintOutLn("Already within target distance, no need to move.", false);
  } else {

    // Move the robot forward until the remaining distance is covered
    while (distanceA2 < remainingdistanceA && distanceB2 < remainingdistanceB) {
      DistanceA();  // Update distance measurements
      DistanceB();

      // Move the robot forward
      motorSpeedA = baseSpeed;
      motorSpeedB = baseSpeed;
      motorA_pwm.write(motorSpeedA);
      motorB_pwm.write(motorSpeedB);

      // Update remaining distance
      remainingDistance = targetDistance - avgDistance;

      Serial.print("Motor A distance: ");
      Serial.print(distanceA * 100);
      Serial.println(" cm");
      Serial.print("Motor B distance: ");
      Serial.print(distanceB * 100);
      Serial.println(" cm");
      PrintOutLn("Remaining Dis: " + String(remainingDistance) + "cm", false);
      //PrintOutLn(String(remainingDistance), false);
    }
  }
  pulseCountDisA = 0;
  pulseCountDisB = 0;
  distanceA = 0;
  distanceB = 0;


  // Stop the robot after reaching the target distance
  brake();
  ThisThread::sleep_for(20ms);

  PrintOutLn("Target distance reached, stopping.", false);
}

void findRightWall() {  // Funtion to locate and move to wall to follow the right wall
  bool rightWallDetected = false;
  int distanceToRightWall = 0;

  PrintOut("Find Right Wall", false);

  for (int i = 1; i <= 5; i++) {
    int checkX = (robotX + 1) + i * dx((robotDir + 1) % 4);  // Check in the right direction
    int checkY = (robotY + 1) + i * dy((robotDir + 1) % 4);

    // Check if we are within bounds and there is a wall
    if (checkX >= 0 && checkX < mazeWidth && checkY >= 0 && checkY < mazeHeight) {
      if (mazeMap[checkY][checkX] == 1) {  // Wall detected
        rightWallDetected = true;
        distanceToRightWall = i;  // Number of grid spaces to the wall
        Serial.print("Right wall detected at ");
        Serial.print(distanceToRightWall);
        Serial.println(" grid spaces away.");
        break;
      }
    }
  }

  // If a right wall is detected
  if (rightWallDetected) {
    turnninetyright();

    ThisThread::sleep_for(50ms);

    //alignFront();

    ThisThread::sleep_for(50ms);


    Serial.print("Moving forward ");
    Serial.print(distanceToRightWall - 2);
    Serial.println(" grid spaces to leave a gap.");

    // Move forward to the wall, leaving one grid space
    moveForward(distanceToRightWall - 2);  // Move forward (distanceToRightWall - 1) grid spaces

    alignFront();



    turnninetyleft();
  } else {
    bool frontWallDetected = false;
    int distanceToFrontWall = 0;

    for (int i = 1; i <= 3; i++) {
      int checkX = (robotX + 1) + i * dx(robotDir);  // Check in the front direction
      int checkY = (robotY + 1) + i * dy(robotDir);

      // Check if we are within bounds and there is a wall
      if (checkX >= 0 && checkX < mazeWidth && checkY >= 0 && checkY < mazeHeight) {
        if (mazeMap[checkY][checkX] == 1) {  // Wall detected
          frontWallDetected = true;
          distanceToFrontWall = i;  // Number of grid spaces to the wall
          Serial.print("Front wall detected at ");
          Serial.print(distanceToFrontWall);
          Serial.println(" grid spaces away.");
          break;
        }
      }
    }

    // If a front wall is detected, follow this logic
    if (frontWallDetected && !rightWallDetected) {
      alignFront();

      // Move forward to the wall, leaving one grid space
      moveForward(distanceToFrontWall - 1);  // Move forward (distanceToFrontWall - 1) grid spaces

      Serial.print("Moving forward ");
      Serial.print(distanceToFrontWall - 1);
      Serial.println(" grid spaces to leave a gap.");

      alignFront();

      turnninetyleft();
    } else {
      while (true) {
        // Move forward one grid space
        moveForward(1);

        // Check for a wall ahead within 5 grid spaces
        bool wallAheadDetected = false;
        for (int i = 1; i <= 7; i++) {
          int checkX = (robotX + 1) + i * dx(robotDir);  // Check in the front direction
          int checkY = (robotY + 1) + i * dy(robotDir);

          if (checkX >= 0 && checkX < mazeWidth && checkY >= 0 && checkY < mazeHeight) {
            if (mazeMap[checkY][checkX] == 1) {  // Wall detected
              wallAheadDetected = true;
              break;
            }
          }
        }

        // Check for a wall to the right within 5 grid spaces
        bool wallRightDetected = false;
        for (int i = 1; i <= 7; i++) {
          int checkX = (robotX + 1) + i * dx((robotDir + 1) % 4);  // Check in the right direction
          int checkY = (robotY + 1) + i * dy((robotDir + 1) % 4);

          if (checkX >= 0 && checkX < mazeWidth && checkY >= 0 && checkY < mazeHeight) {
            if (mazeMap[checkY][checkX] == 1) {  // Wall detected
              wallRightDetected = true;
              break;
            }
          }
        }

        // If a wall is detected either ahead or to the right, stop and break out of the loop
        if (wallAheadDetected || wallRightDetected) {
          break;
        }
      }
    }
  }
}
/*
bool rightWallLocked = false;  // Flag to indicate if the right wall is found

void findRightWall_test() {      // to test
    bool rightWallDetected = false;
    int distanceToRightWall = 0;

    PrintOut("Find Right Wall", false);

    // If the wall is not locked, search for it
    if (!rightWallLocked) {
        for (int i = 1; i <= 7; i++) {
            int checkX = robotX + i * dx((robotDir + 1) % 4);  
            int checkY = robotY + i * dy((robotDir + 1) % 4);

            if (checkX >= 0 && checkX < mazeWidth && checkY >= 0 && checkY < mazeHeight) {
                if (mazeMap[checkY][checkX] == 1) {  // Wall detected
                    rightWallDetected = true;
                    distanceToRightWall = i;
                    Serial.print("Right wall detected at ");
                    Serial.print(distanceToRightWall);
                    Serial.println(" grid spaces away.");
                    break;
                }
            }
        }
    } else {
        rightWallDetected = true;  // If locked, assume the wall is still there
    }

    // If a right wall is detected, lock onto it
    if (rightWallDetected) {
        rightWallLocked = true;  // Lock the wall so it doesn't search again
        turnninetyright();
        ThisThread::sleep_for(50ms);
        moveForward(distanceToRightWall - 2);
        alignFront();
        turnninetyleft();
    } else {
        // If no right wall is detected, continue normal behavior
        moveForward(1);
        findRightWall();  // Retry if no right wall is found
    }
}

void moveToWall(int distanceToWall) {  // Moves forward to leave a gap before the wall
    PrintOut("Move To Wall", false);
    if (distanceToWall > 1) {
        Serial.print("Moving forward ");
        Serial.print(distanceToWall - 2);
        Serial.println(" grid spaces to leave a gap.");

        moveForward(distanceToWall - 2);
        alignFront();
    }
}

void findRightWall() {  // Function to locate and move to the right wall
    bool rightWallDetected = false;
    int distanceToRightWall = 0;

    PrintOut("Find Right Wall", false);

    for (int i = 1; i <= 7; i++) {
        int checkX = (robotX + 1) + i * dx((robotDir + 1) % 4);  // Check in the right direction
        int checkY = (robotY + 1) + i * dy((robotDir + 1) % 4);

        if (checkX >= 0 && checkX < mazeWidth && checkY >= 0 && checkY < mazeHeight) {
            if (mazeMap[checkY][checkX] == 1) {  // Wall detected
                rightWallDetected = true;
                distanceToRightWall = i;  // Number of grid spaces to the wall
                Serial.print("Right wall detected at ");
                Serial.print(distanceToRightWall);
                Serial.println(" grid spaces away.");
                break;
            }
        }
    }

    if (rightWallDetected) {
        turnninetyright();
        ThisThread::sleep_for(50ms);
        moveToWall(distanceToRightWall);
        turnninetyleft();
    } else {
        moveForward(1);  // If no right wall, move forward one grid space
    }
}*/


//----------------------------------------------------------------------------------


//Mapping---------------------------------------------------------------------------

void initializeMazeMap() {  // Initialize map
  // Set all cells to unknown (-1)
  for (int y = 0; y < mazeHeight; y++) {
    for (int x = 0; x < mazeWidth; x++) {
      mazeMap[y][x] = -1;  // -1 represents unknown
    }
  }
}

void displayMazeMap() {  // Display the map in serial
  Serial.println("Current Maze Map:");

  //const int finishCenterX = 15;
  //const int finishCenterY = 40;

  for (int y = 0; y < mazeHeight; y++) {
    for (int x = 0; x < mazeWidth; x++) {
      if (x == finishCenterX && y == finishCenterY) {
        Serial.print(" F ");  // Mark the finish center position
      } else if (mazeMap[y][x] == 1) {
        Serial.print(" W ");  // Wall
      } else if (mazeMap[y][x] == -1) {
        Serial.print(" # ");  // Unknown
      } else if (mazeMap[y][x] == 0) {
        Serial.print(" . ");  // Empty space
      } else if (mazeMap[y][x] == 3) {
        Serial.print(" R ");  // Robot body
      } else if (mazeMap[y][x] == 2) {
        // Represent the robot's center with directional arrows
        if (robotDir == 0) {
          Serial.print(" ↑ ");  // Facing Up
        } else if (robotDir == 1) {
          Serial.print(" → ");  // Facing Right
        } else if (robotDir == 2) {
          Serial.print(" ↓ ");  // Facing Down
        } else if (robotDir == 3) {
          Serial.print(" ← ");  // Facing Left
        }
      }
    }
    Serial.println();  // Move to the next row
  }
  Serial.println();  // Add an extra newline for readability
}

void updateMazeMap() {  // Updates robots position
  // Clear old robot positions
  for (int y = 0; y < mazeHeight; y++) {
    for (int x = 0; x < mazeWidth; x++) {
      if (mazeMap[y][x] == 3 || mazeMap[y][x] == 2) {
        mazeMap[y][x] = 0;  // Mark as free space
      }
    }
  }

  // Mark all the cells occupied by the robot
  for (int i = -1; i <= 1; i++) {  // Offset for the 3x3 grid
    for (int j = -1; j <= 1; j++) {

      int surroundingX = robotX + j;
      int surroundingY = robotY + i;

      // Ensure the grid coordinates are within bounds
      if (surroundingX >= 0 && surroundingX < mazeWidth && surroundingY >= 0 && surroundingY < mazeHeight) {
        mazeMap[surroundingY][surroundingX] = 3;  // Robot

        /*Serial.print("Marked grid at (");
        Serial.print(surroundingX);
        Serial.print(", ");
        Serial.print(surroundingY);
        Serial.println(") as empty.");*/
      }
    }
  }
  // Mark the robot's center position as 'X'
  if (robotX >= 0 && robotX < mazeWidth && robotY >= 0 && robotY < mazeHeight) {
    mazeMap[robotY][robotX] = 2;  // Use 2 to represent the robot in the map
  }

  // Display robot's new position
  Serial.print("Robot's position marked at: (");
  Serial.print(robotX);
  Serial.print(", ");
  Serial.println(robotY);
}

void displayMazeMapOverBLE() {  // Display maze over Bluetooth
  String mazeStr = "";

  // Convert the maze map into a string to send over BLE
  for (int y = 0; y < mazeHeight; y++) {
    String rowStr = "";
    for (int x = 0; x < mazeWidth; x++) {
      if (mazeMap[y][x] == 1) {
        mazeStr += "W";  // Wall
      } else if (mazeMap[y][x] == -1) {
        mazeStr += "#";  // Unknown
      } else if (mazeMap[y][x] == 0) {
        mazeStr += ".";  // Empty space
      } else if (mazeMap[y][x] == 3) {
        mazeStr += "R";  // Robot body
      } else if (mazeMap[y][x] == 2) {
        // Represent the robot's center with directional arrows
        if (robotDir == 0) {
          mazeStr += "↑";  // Facing Up
        } else if (robotDir == 1) {
          mazeStr += "→";  // Facing Right
        } else if (robotDir == 2) {
          mazeStr += "↓";  // Facing Down
        } else if (robotDir == 3) {
          mazeStr += "←";  // Facing Left
        }
      }
      // Ensure each row has exactly 35 characters
      while (rowStr.length() < 35) {
        rowStr += " ";  // Pad with spaces if needed
      }
    }
    mazeStr += "\n";  // New line for each row
  }

  // Convert String to const char* and send it over BLE in chunks (max 20 bytes per packet)
  const char* mazeData = mazeStr.c_str();  // Convert String to const char*
  int length = strlen(mazeData);           // Get the length of the C-string

  for (int i = 0; i < length; i += 35) {
    String chunk = String(mazeData).substring(i, i + 35);  // Get a chunk of the maze data
    txCharacteristic.writeValue(chunk.c_str());            // Send the chunk via BLE
    ThisThread::sleep_for(100ms);                          // Small delay to ensure data is transmitted correctly
  }

  Serial.println("Maze sent over BLE!");
}

void processSensorData(float sensorDistance, int startX, int startY, int dx, int dy, bool) {  // Calculates number of grids free ahead of each sensor
  const int maxDistanceCm = 50;                                                               // Maximum distance to consider
  const int gridSizeCm = 5;                                                                   // Size of each grid cell in cm
  int offset = 1;


  // Convert distance to grid cells
  int maxGridSpaces = maxDistanceCm / gridSizeCm;  // Max grid spaces (50 cm = 10 grids)
  int freeSpaces = min(sensorDistance / gridSizeCm, maxGridSpaces);
  //Serial.print("Free spaces");
  //Serial.println(freeSpaces);
  // Mark free spaces
  for (int i = 1; i <= freeSpaces; i++) {  // Start from 1 to skip the robot's position
    int gridX = startX + i * dx;
    int gridY = startY + i * dy;

    // Ensure within maze bounds
    if (gridX >= 0 && gridX < mazeWidth && gridY >= 0 && gridY < mazeHeight) {
      mazeMap[gridY][gridX] = 0;  // Mark as free space
    }
  }

  // Mark the wall (if within bounds)
  if (freeSpaces < maxGridSpaces) {  // Only mark a wall if there's a limit
    int wallX = startX + (freeSpaces + offset) * dx;
    int wallY = startY + (freeSpaces + offset) * dy;

    if (wallX >= 0 && wallX < mazeWidth && wallY >= 0 && wallY < mazeHeight) {
      mazeMap[wallY][wallX] = 1;  // Mark as wall
    }
  }
}

void checkSensorsAndUpdateMaze() {  // Using processsesnordata it marks walls and free spaces on the map
  // Sensor threshold for detecting walls
  float Threshold = 50.0;     // Adjust as per environment (in cm)
  int maxDistanceCells = 10;  // Maximum grid cells to mark free

  // Directions for the robot's facing direction
  int forwardDx = dx(robotDir);  // X direction for facing forward
  int forwardDy = dy(robotDir);  // Y direction for facing forward
  int leftDx = dy(robotDir);     // X direction for left of facing
  int leftDy = -dx(robotDir);    // Y direction for left of facing
  int rightDx = -dy(robotDir);   // X direction for right of facing
  int rightDy = dx(robotDir);    // Y direction for right of facing

  // Compute sensor positions relative to the robot
  int F1_startX = robotX + leftDx + forwardDx;  // F1 is one grid left and forward
  int F1_startY = robotY + leftDy + forwardDy;
  int F2_startX = robotX + rightDx + forwardDx;  // F2 is one grid right and forward
  int F2_startY = robotY + rightDy + forwardDy;
  int R1_startX = robotX + forwardDx + rightDx;  // R1 is one grid forward and right
  int R1_startY = robotY + forwardDy + rightDy;
  int R2_startX = robotX - forwardDx + rightDx;  // R2 is one grid backward and right
  int R2_startY = robotY - forwardDy + rightDy;
  int L_startX = robotX + leftDx;  // L is one grid left and forward
  int L_startY = robotY + leftDy;

  // Process the front-left sensor (F1)
  if (distance_F1 < Threshold) {
    //Serial.print(distance_F1);
    //Serial.println("Wall detected by F1.");
    processSensorData(distance_F1, F1_startX, F1_startY, forwardDx, forwardDy, true);
  } else {
    //Serial.println("No wall detected by F1.");
    processSensorData(distance_F1, F1_startX, F1_startY, forwardDx, forwardDy, false);
  }

  // Process the front-right sensor (F2)
  if (distance_F2 < Threshold) {
    //Serial.print(distance_F2);
    //Serial.println("Wall detected by F2.");
    processSensorData(distance_F2, F2_startX, F2_startY, forwardDx, forwardDy, true);
  } else {
    //Serial.println("No wall detected by F2.");
    processSensorData(distance_F2, F2_startX, F2_startY, forwardDx, forwardDy, false);
  }

  if (distance_R1 < Threshold) {
    //Serial.print(distance_R1);
    //Serial.println("Wall detected by R1.");
    processSensorData(distance_R1, R1_startX, R1_startY, rightDx, rightDy, true);
  } else {
    //Serial.println("No wall detected by R1.");
    processSensorData(distance_R1, R1_startX, R1_startY, rightDx, rightDy, false);
  }

  // Process the right sensor (R)
  if (distance_R2 < Threshold) {
    //Serial.print(distance_R2);
    //Serial.println("Wall detected by R2.");
    processSensorData(distance_R2, R2_startX, R2_startY, rightDx, rightDy, true);
  } else {
    //Serial.println("No wall detected by R2.");
    processSensorData(distance_R2, R2_startX, R2_startY, rightDx, rightDy, false);
  }

  // Process the left sensor (L)
  if (distance_L < Threshold) {
    //Serial.print(distance_L);
    //Serial.println("Wall detected by L.");
    processSensorData(distance_L, L_startX, L_startY, leftDx, leftDy, true);
  } else {
    //Serial.println("No wall detected by L.");
    processSensorData(distance_L, L_startX, L_startY, leftDx, leftDy, false);
  }
}

void smartMapping() {  // Fixes gaps in mapping and cleans up stray walls
  for (int y = 1; y < mazeHeight - 1; y++) {
    for (int x = 1; x < mazeWidth - 1; x++) {
      if (mazeMap[y][x] == -1 || mazeMap[y][x] == 0 || mazeMap[y][x] == 1) {
        // Check if the unknown cell is surrounded by walls on the same row (y-axis)
        if (mazeMap[y][x - 1] == 1 && mazeMap[y][x + 1] == 1) {
          mazeMap[y][x] = 1;  // Mark as wall
          clearPathToWall(robotX, robotY, x, y);
        }
        // Check if the unknown cell is surrounded by walls on the same column (x-axis)
        if (mazeMap[y - 1][x] == 1 && mazeMap[y + 1][x] == 1) {
          mazeMap[y][x] = 1;  // Mark as wall
          clearPathToWall(robotX, robotY, x, y);
        }
        // Check if the unknown cell is between two free spaces (0) within a 4-cell range from the robot
        if (abs(robotX - x) <= 4) {  // Check horizontal range
          if (mazeMap[y][x - 1] == 0 && mazeMap[y][x + 1] == 0) {
            mazeMap[y][x] = 0;  // Mark as free space
          }
        }
        if (abs(robotY - y) <= 4) {  // Check vertical range
          if (mazeMap[y - 1][x] == 0 && mazeMap[y + 1][x] == 0) {
            mazeMap[y][x] = 0;  // Mark as free space
          }
        }
      }
    }
  }
  for (int y = 1; y < mazeHeight - 1; y++) {  // Happens after the map has been fully updated
    for (int x = 1; x < mazeWidth - 1; x++) {
      if (mazeMap[y][x] == 1) {  // Check for wall
        if (mazeMap[y - 1][x] == 0 && mazeMap[y + 1][x] == 0 && mazeMap[y][x - 1] == 0 && mazeMap[y][x + 1] == 0) {
          mazeMap[y][x] = 0;  // Convert lone wall to free space
        }
      }
    }
  }
}


void clearPathToWall(int startX, int startY, int endX, int endY) {  // clears all spaces between a wall and robot
  // Check if the path is horizontal or vertical
  if (startX == endX) {  // Vertical path
    int minY = min(startY, endY);
    int maxY = max(startY, endY);
    for (int y = minY + 1; y < maxY; y++) {                       // Avoid marking the robot's position or the wall itself
      if (mazeMap[y][startX] == -1 || mazeMap[y][startX] == 1) {  // Mark as free space if it was unknown
        mazeMap[y][startX] = 0;                                   // Free space
      }
    }
  } else if (startY == endY) {  // Horizontal path
    int minX = min(startX, endX);
    int maxX = max(startX, endX);
    for (int x = minX + 1; x < maxX; x++) {                       // Avoid marking the robot's position or the wall itself
      if (mazeMap[startY][x] == -1 || mazeMap[startY][x] == 1) {  // Mark as free space if it was unknown
        mazeMap[startY][x] = 0;                                   // Free space
      }
    }
  }
}

// Thread to check for change in direction and grids travelled call updatemazemap
void MovementMapping() {
  while (runningMapping) {
    // Store the robot's last known state
    static int lastRobotX = robotX;
    static int lastRobotY = robotY;
    static int lastRobotDir = robotDir;

    bool hasMoved = false;
    bool hasTurned = false;

    // Check if the robot moved to a new grid cell
    if (robotX != lastRobotX || robotY != lastRobotY) {
      Serial.println("Robot moved. Scanning the maze.");
      hasMoved = true;
      lastRobotX = robotX;
      lastRobotY = robotY;
    }

    // Check if the robot turned to a new direction
    if (robotDir != lastRobotDir) {
      Serial.println("Robot turned. Scanning the maze.");
      hasTurned = true;
      lastRobotDir = robotDir;
    }

    // If the robot moved or turned, update the maze
    if (hasMoved || hasTurned) {
      updateMazeMap();              // Update the maze with the current robot position
      checkSensorsAndUpdateMaze();  // Scan and update maze walls or obstacles
      PrintOutLn("Updated Position:", false);
      PrintOutLn("X: " + String(robotX) + " Y: " + String(robotY), false);
      PrintOutLn("Robot Direction:", false);
      if (robotDir == 0) {
        PrintOutLn("North", false);
      } else if (robotDir == 1) {
        PrintOutLn("East", false);
      } else if (robotDir == 2) {
        PrintOutLn("South", false);
      } else if (robotDir == 3) {
        PrintOutLn("West", false);
      }
      //PrintOutLn(String(robotDir), false);
    }
  }
}

int dx(int direction) {
  // Determine how to move in the X direction based on the robot's orientation
  if (direction == 1) {
    return 1;  // Move right, East
  } else if (direction == 3) {
    return -1;  // Move left, West
  }
  return 0;  // No movement in X
}

int dy(int direction) {
  // Determine how to move in the Y direction based on the robot's orientation
  if (direction == 0) {
    return -1;  // Move up, North
  } else if (direction == 2) {
    return 1;  // Move down, South
  }
  return 0;  // No movement in Y
}

//----------------------------------------------------------------------------------

//Djikstra--------------------------------------------------------------------------
// Dijkstra code calculates the shortest path though free spaces to designated end position


struct Node {
  int x, y, cost;
  bool operator>(const Node& other) const {
    return cost > other.cost;
  }
};

int dist[mazeHeight][mazeWidth];
pair<int, int> prevNode[mazeHeight][mazeWidth];

int dx_maze[] = { -1, 1, 0, 0 };  // Up, Down, Left, Right
int dy_maze[] = { 0, 0, -1, 1 };


bool hasClearance(int x, int y) {    // Clearence that puts a 3x3 buffer around center
  for (int i = -1; i <= 1; i++) {    // Change 1 to two for 5x5
    for (int j = -1; j <= 1; j++) {  // Change 1 to two for 5x5
      int nx = x + i, ny = y + j;
      if (nx < 0 || ny < 0 || nx >= mazeHeight || ny >= mazeWidth || mazeMap[nx][ny] == 1 || mazeMap[nx][ny] == -1) {
        return false;  // Obstacle or out of bounds
      }
    }
  }
  return true;
}


void dijkstra(int startY, int startX, int endY, int endX) {
  for (int i = 0; i < mazeHeight; i++) {
    for (int j = 0; j < mazeWidth; j++) {
      dist[i][j] = numeric_limits<int>::max();
      prevNode[i][j] = { -1, -1 };
    }
  }

  priority_queue<Node, vector<Node>, greater<Node>> pq;
  pq.push({ startX, startY, 0 });
  dist[startX][startY] = 0;

  while (!pq.empty()) {
    Node current = pq.top();
    pq.pop();
    int x = current.x, y = current.y;

    if (x == endX && y == endY) {
      Serial.println("End found");
      break;
    };

    Serial.print("x = ");
    Serial.print(x);
    Serial.print("y = ");
    Serial.println(y);

    for (int i = 0; i < 4; i++) {
      int nx = x + dx_maze[i], ny = y + dy_maze[i];
      if (nx >= 0 && ny >= 0 && nx < mazeHeight && ny < mazeWidth && hasClearance(nx, ny)) {

        int newCost = dist[x][y] + 1;
        if (newCost < dist[nx][ny]) {
          dist[nx][ny] = newCost;
          prevNode[nx][ny] = { x, y };
          pq.push({ nx, ny, newCost });
        }
      }
    }
  }
}

void printMazeWithPath(int endY, int endX) {
  char displayMaze[mazeHeight][mazeWidth];

  // Copy maze to displayMaze
  for (int i = 0; i < mazeHeight; i++) {
    for (int j = 0; j < mazeWidth; j++) {
      if (mazeMap[i][j] == 1) {
        displayMaze[i][j] = 'W';  // Wall
      } else if (mazeMap[i][j] == -1) {
        displayMaze[i][j] = '#';  // Unknown space
      } else {
        displayMaze[i][j] = '.';  // Open space
      }
    }
  }


  // Mark the path
  vector<pair<int, int>> path;
  for (pair<int, int> at = { endX, endY }; at.first != -1; at = prevNode[at.first][at.second]) {
    path.push_back(at);
  }
  Serial.println("Extracted path BEFORE reversing:");
  for (auto p : path) {
    Serial.print("(");
    Serial.print(p.first);
    Serial.print(",");
    Serial.print(p.second);
    Serial.print(") → ");
  }
  Serial.println();

  reverse(path.begin(), path.end());  // Reverse the path

  Serial.println("Extracted path AFTER reversing:");
  PrintOutLn("Extracted Path:", false);
  for (auto p : path) {
    Serial.print("(");
    Serial.print(p.first);
    Serial.print(",");
    Serial.print(p.second);
    Serial.print(") → ");
    PrintOutLn("(" + String(p.first) + "," + String(p.second) + ")", false);
    PrintOutLn("↓", false);
  }
  Serial.println();
  PrintOutLn("", false);  // Optional: Adds a blank line after printing all coordinates

  for (auto p : path) {
    displayMaze[p.first][p.second] = 'P';
  }

  // Mark start and end
  displayMaze[robotY][robotX] = 'S';  // Start Position
  displayMaze[startY][startX] = 'E';  // End Position

  // Print the maze
  Serial.println("Maze with Shortest Path:");
  for (int i = 0; i < mazeHeight; i++) {
    for (int j = 0; j < mazeWidth; j++) {
      Serial.print(displayMaze[i][j]);
      Serial.print(" ");
    }
    Serial.println();
  }
  // Print the path in (x,y) format
  Serial.print("Path: ");
  for (size_t i = 0; i < path.size(); i++) {
    Serial.print("(");
    Serial.print(path[i].first);
    Serial.print(",");
    Serial.print(path[i].second);
    Serial.print(")");
    if (i < path.size() - 1) {
      Serial.print(" → ");
    }
  }
  Serial.println();
  Serial.print("Path size: ");
  Serial.println(path.size());  // Debug print to see path size
}


void convertPathToMoves(vector<pair<int, int>>& path) {  // Converts path to move
  Serial.println("IN FUNC");

  if (path.empty()) {
    Serial.println("Path is empty. No movement.");
    return;
  }

  Serial.print("Path size: ");
  Serial.println(path.size());  // Debug print to see path size

  int currentDir = robotDir;  //2;  // Assuming starting direction is 2 (adjust if needed)
  size_t i = 1;               // Start from the second node in the path

  while (i < path.size()) {
    Serial.println("IN WHILE");
    int dx = path[i].first - path[i - 1].first;
    int dy = path[i].second - path[i - 1].second;

    int nextDir;
    if (dx == -1 && dy == 0) nextDir = 0;  // Moving UP
    if (dx == 1 && dy == 0) nextDir = 1;   // Moving DOWN
    if (dx == 0 && dy == -1) nextDir = 3;  // Moving LEFT
    if (dx == 0 && dy == 1) nextDir = 2;   // Moving RIGHT

    // Adjust direction if needed
    if (currentDir != nextDir) {
      Serial.print("Adjusting direction from ");
      Serial.print(currentDir);
      Serial.print(" to ");
      Serial.println(nextDir);
      if ((currentDir == 0 && nextDir == 3) || (currentDir == 3 && nextDir == 1) || (currentDir == 1 && nextDir == 2) || (currentDir == 2 && nextDir == 0)) {
        Serial.println("Turning left");
        turnninetyleft();
      } else if ((currentDir == 0 && nextDir == 2) || (currentDir == 2 && nextDir == 1) || (currentDir == 1 && nextDir == 3) || (currentDir == 3 && nextDir == 0)) {
        Serial.println("Turning right");
        turnninetyright();
      } else {
        Serial.println("Turning 180 degrees");
        turnninetyleft();
        turnninetyleft();  // 180-degree turn
      }
      currentDir = nextDir;
    }

    // Count how many grids we can move in a straight line
    int moveCount = 1;
    while (i + 1 < path.size() && path[i + 1].first - path[i].first == dx && path[i + 1].second - path[i].second == dy) {

      moveCount++;
      i++;

      Serial.print("Increasing move count: ");
      Serial.println(moveCount);
      Serial.print("Next target position: ");
      Serial.print(path[i].first);
      Serial.print(", ");
      Serial.println(path[i].second);
    }

    // Move forward in one call
    Serial.print("Moving forward ");
    Serial.print(moveCount);
    Serial.println(" steps");

    Serial.print("Before moving: ");
    Serial.print(robotX);
    Serial.print(", ");
    Serial.println(robotY);

    moveForward(moveCount);

    Serial.print("After moving: ");
    Serial.print(robotX);
    Serial.print(", ");
    Serial.println(robotY);

    i++;
  }
}

vector<pair<int, int>> extractPath(int startX, int startY) {
  vector<pair<int, int>> path;
  for (pair<int, int> at = { startX, startY }; at.first != -1; at = prevNode[at.first][at.second]) {
    Serial.print("(");
    Serial.print(at.first);
    Serial.print(", ");
    Serial.print(at.second);
    Serial.print(") → ");
    path.push_back(at);
  }

  reverse(path.begin(), path.end());  // Reverse to follow path from robot → start
  Serial.println("Path extracted.");
  return path;
}

/*void returnToStart() {
  Serial.println("Starting return to start...");
  dijkstra(robotX, robotY, startX, startY);
  //printMazeWithPath(startX, startY);                          // Solve from robot's position to start
  vector<pair<int, int>> path = extractPath(startX, startY);  // Get the shortest path

  if (path.empty()) {
    Serial.println("No valid path found to start!");
    return;
  }

  Serial.println("Returning to start...");
  convertPathToMoves(path);  // Convert path into robot movement commands
}*/

void returnToStart() {
  Serial.println("Starting return to start...");

  // Manually define a longer path for testing
  vector<pair<int, int>> path = {
    { robotX, robotY }, { robotX, robotY + 1 }, { robotX, robotY + 2 }, { robotX, robotY + 3 }, { robotX, robotY + 4 }, { robotX + 1, robotY + 4 }, { robotX + 2, robotY + 4 }, { robotX + 3, robotY + 4 }, { startX, startY }
  };

  Serial.print("Manually set path size: ");
  Serial.println(path.size());

  if (path.empty()) {
    Serial.println("No valid path found to start!");
    return;
  }

  Serial.println("Returning to start...");
  convertPathToMoves(path);  // Convert path into robot movement commands
}




//----------------------------------------------------------------------------------

bool wallAhead() {
  const float gridSizeCm = 5.0;
  float targetDistance;                                        // Grid size in cm
  float avgFrontDistance = (distance_F1 + distance_F2) / 2.0;  // Average front distance
  if (distance_F1 <= 3 * gridSizeCm && distance_F2 > 4 * gridSizeCm) {
    targetDistance = ceil(distance_F1 / gridSizeCm) * gridSizeCm;  // Round up to nearest 5 cm
    dontAlign = true;
    //PrintOutLn("First if", false);
  } else if (distance_F2 <= 3 * gridSizeCm && distance_F1 > 4 * gridSizeCm) {
    targetDistance = ceil(distance_F2 / gridSizeCm) * gridSizeCm;  // Round up to nearest 5 cm
    dontAlign = true;
    //PrintOutLn("Second if", false);

  } else {
    targetDistance = ceil(avgFrontDistance / gridSizeCm) * gridSizeCm;  // Round up to nearest 5 cm
  }
  Serial.println(avgFrontDistance);
  Serial.println(targetDistance);

  return targetDistance <= (3 * gridSizeCm);
}

/*
bool wallRight() {
  const float gridSizeCm = 5.0;
  float avgRightDistance = (distance_R1 + distance_R2) / 2.0;               // Average right sensor distance
  float targetDistance = ceil(avgRightDistance / gridSizeCm) * gridSizeCm;  // Round up to nearest 5 cm

  return targetDistance <= (3 * gridSizeCm);  // True if the right wall is within one grid space
}
*/

bool wallLeft() {
  const float gridSizeCm = 5.0;
  float targetDistance = ceil(distance_L / gridSizeCm) * gridSizeCm;  // Round up left sensor distance to nearest 5 cm

  return targetDistance <= (2 * gridSizeCm);  // True if the left wall is within one grid space
}

bool gapOnRight() {
  return abs(distance_R1 - distance_R2) >= 15.0;
}

void decisionMaker() {
  // Define the center of the determined 3x3 grid area

  checkSensorsAndUpdateMaze();
  updateMazeMap();
  smartMapping();
  displayMazeMap();
  displayMazeMapOverBLE();
  ThisThread::sleep_for(200ms);

  while (!(robotX >= finishCenterX - 5 && robotX <= finishCenterX + 5 && robotY >= finishCenterY - 3 && robotY <= finishCenterY + 5)) {
    //PrintOutLn("Traversing Maze", false);
    dontAlign = false;
    if (wallAhead() && gapOnRight()) {
      PrintOutLn("Wall ahead & gap on right", false);
      alignFront();
      ThisThread::sleep_for(200ms);
      turnninetyright();
      ThisThread::sleep_for(200ms);
      moveForward(5);
      ThisThread::sleep_for(200ms);
      //findRightWall();
      ThisThread::sleep_for(200ms);
    } else if (wallAhead() && !gapOnRight()) {
      PrintOutLn("Wall ahead & NO gap on right", false);
      alignFront();
      ThisThread::sleep_for(200ms);
      turnninetyleft();
      ThisThread::sleep_for(200ms);
    } else if (!wallAhead() && gapOnRight()) {
      PrintOutLn("No wall ahead & gap on right", false);
      moveForward(4);
      PrintOutLn("Out first", false);
      ThisThread::sleep_for(200ms);
      turnninetyright();
      ThisThread::sleep_for(200ms);
      moveForward(5);
      PrintOutLn("Out Second", false);
      ThisThread::sleep_for(200ms);
      //findRightWall();
      ThisThread::sleep_for(200ms);
    } else if (!wallAhead() && !gapOnRight()) {
      PrintOutLn("No wall ahead & NO gap on right", false);
      maintainDistancefromRightWall();
    }
  }
  PrintOutLn("Within Finish", false);
  brake();
  moveToFinish();
}

/*void moveToFinish() {

  PrintOutLn("Robot entered 3x3 grid. Moving to center.", false);

  // Move to center of 3x3 grid
  while (robotX != finishCenterX || robotY != finishCenterY) {
    if (robotX < finishCenterX) {
      moveForward(1);
      robotX++;
    } else if (robotX > finishCenterX) {
      moveForward(1);
      robotX--;
    }
    if (robotY < finishCenterY) {
      moveForward(1);
      robotY++;
    } else if (robotY > finishCenterY) {
      moveForward(1);
      robotY--;
    }
  }

  // Turn to face direction 2
  PrintOutLn("Reaching center. Adjusting direction to face 2.", false);
  if (robotDir == 0) {
    turnninetyright();
    turnninetyright();
  } else if (robotDir == 1) {
    turnninetyleft();
  } else if (robotDir == 3) {
    turnninetyright();
  }

  PrintOutLn("Robot centered and facing direction 2.", false);
}*/

void moveToFinish() {
  PrintOutLn("Adjusting direction to face south (2).", false);

  // Ensure the robot is facing direction 2 (down/south)
  if (robotDir == 0) {  // Facing up, needs to turn 180°
    turnninetyright();
    turnninetyright();
  } else if (robotDir == 1) {  // Facing right
    turnninetyright();
  } else if (robotDir == 3) {  // Facing left
    turnninetyleft();
  }

  PrintOutLn("Robot now facing south (2).", false);
}


void setup() {

  Serial.begin(9600);
  while (!Serial)
    ;

  if (!BLE.begin()) {
    Serial.println("Failed to initialize BLE!");
    while (1)
      ;
  }

  BLE.setLocalName("Theseus");
  BLE.setAdvertisedService(uartService);

  uartService.addCharacteristic(txCharacteristic);
  uartService.addCharacteristic(rxCharacteristic);
  BLE.addService(uartService);

  BLE.advertise();
  Serial.println("BLE UART Ready. Open Bluefruit Connect App.");

  // Initialize Serial communication at 9600 baud rate
  Serial.begin(9600);
  Serial.println("Serial communication started.");

  // Set PWM period (optional, depending on motor driver requirements)
  motorA_pwm.period(0.001);  // Set PWM period to 1 ms for motor 1
  motorB_pwm.period(0.001);  // Set PWM period to 1 ms for motor 2

  // Set motor directions
  motorA_dir = 1;  // Set motor 1 to forward direction
  motorB_dir = 0;  // Set motor 2 to reverse direction

  // Set motor speeds
  motorA_pwm.write(motor_speed);  // Set speed for motor 1
  motorB_pwm.write(motor_speed);  // Set speed for motor 2

  // Attach interrupts for encoder signals
  encoderA.fall(&encoderISR_A);  // Interrupt on falling edge of Motor A encoder
  encoderB.fall(&encoderISR_B);  // Interrupt on falling edge of Motor B encoder

  // Start timer for speed calculation
  speedTimer.start();

  SensorsThread.start(checksensors);

  MappingThread.start(MovementMapping);

  distanceThread.start(measureAverageDistance);


  initializeMazeMap();

  checkSensorsAndUpdateMaze();
  updateMazeMap();
  displayMazeMap();

  //alignRobot();
}

void alignRobot() {  // Aligns robot at the begining for accurate positioning
  // Step 1: Align to the front (5 cm from the front wall)
  turnninetyleft();


  alignFront();



  ThisThread::sleep_for(100ms);

  moveToDistance(5);  // Move forward until front sensors are 7.5 cm away

  ThisThread::sleep_for(100ms);


  // Step 2: Turn 90 degrees right
  turnninetyleft();

  // Step 3: Align to the new front (after turning, it is the previous right side)
  alignFront();

  ThisThread::sleep_for(100ms);


  moveToDistance(5);  // Move forward until front sensors are 7.5 cm away

  ThisThread::sleep_for(100ms);
  // Step 4: Turn 90 degrees right again
  turnninetyleft();
}

void moveToDistance(float targetDistance) {  // Move the robot forward until both front sensors detect the desired distance from the wall
  const float buffer = 0.25;
  const float baseSpeed = 0.3;  // Base motor speed

  pulseCountDisA = 0;
  pulseCountDisB = 0;
  distanceA = 0;
  distanceB = 0;

  equalizeMotor();


  while (true) {

    if (distance_F1 > targetDistance + buffer && distance_F2 > targetDistance + buffer) {
      forward();
      motorSpeedA = baseSpeed;
      motorSpeedB = baseSpeed;
    } else if (distance_F1 < targetDistance - buffer && distance_F2 < targetDistance - buffer) {
      // If both sensors are less than the target - buffer, brake (stop)
      reverse();
      motorSpeedA = baseSpeed;
      motorSpeedB = baseSpeed;
      break;  // Exit the loop once the robot is stopped
    } else if (distance_F1 <= targetDistance + buffer && distance_F2 <= targetDistance + buffer || distance_F1 >= targetDistance - buffer && distance_F2 >= targetDistance - buffer) {
      brake();
      break;  // Exit the loop once the robot is in the buffer zone
    }
    ThisThread::sleep_for(50ms);  // Small delay to give the robot time to adjust its position
  }
}

// Commands
void processCommand(char command) {
  if (command == 'w') {
    Serial.print("Motor A distance: ");
    Serial.print(distanceA * 100);
    Serial.println(" cm");
    Serial.print("Motor B distance: ");
    Serial.print(distanceB * 100);
    Serial.println(" cm");
    Serial.print("Distance Travelled A and B ");
    Serial.print(avgDistance * 100);
    Serial.println("cm");
  } else if (command == 'a') {
    alignRobot();
  } else if (command == 'd') {
    decisionMaker();
  } else if (command == 's') {
    checksensorscheck();
  } else if (command == 'b') {
    TurnRightAngle(12);
  } else if (command == 'g') {
    moveForward(1);
  } else if (command == 'r') {
    returnToStart();
  } else if (command == 'm') {
    dijkstra(robotX, robotY, startX, startY);
    printMazeWithPath(startX, startY);
    //displaySolvedMazeOverBLE(startX, startY);
  } else if (command == 'l') {
    turnninetyleft();
  } else if (command == 'j') {
    turnninetyright();
  } else if (command == 'p') {
    checkSensorsAndUpdateMaze();
    updateMazeMap();
    smartMapping();
    displayMazeMap();
    displayMazeMapOverBLE();
  } else if (command == 'f') {
    finishGridSpace();
  } else if (command == 'o') {
    findRightWall();
  } else if (command == 'k') {
    maintainDistancefromRightWall();
  } else if (command == 'y') {
    alignFront();
  } else if (command >= '1' && command <= '9') {  // If command is a digit (1-9)
    int numCells = command - '0';                 // Convert char to integer
    //Serial.print("Moving forward by ");
    //Serial.print(numCells);
    //Serial.println(" grid spaces.");
    moveForward(numCells);
  }
}

void loop() {
  BLEDevice central = BLE.central();

  if (central) {
    Serial.print("Connected to: ");
    Serial.println(central.address());

    while (central.connected()) {
      // Check Bluetooth input
      if (rxCharacteristic.written()) {
        char command = rxCharacteristic.value()[0];
        Serial.print("Received from BLE: ");
        Serial.println(command);
        processCommand(command);
      }
      // Check Serial input (USB)
      if (Serial.available() > 0) {
        char command = Serial.read();
        Serial.print("Received from Serial: ");
        Serial.println(command);
        processCommand(command);
      }
    }
    Serial.println("Disconnected");
  }

  // Always check Serial input, even if no BLE connection
  if (Serial.available() > 0) {
    char command = Serial.read();
    Serial.print("Received from Serial: ");
    Serial.println(command);
    processCommand(command);
  }
}
