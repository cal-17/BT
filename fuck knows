#include <mbed.h>
#include <ArduinoBLE.h>
#include <iostream>
#include <vector>
#include <queue>
#include <climits>


//Bluetooth--------------------------------------------------------------------------
BLEService uartService("6E400001-B5A3-F393-E0A9-E50E24DCCA9E");  // Nordic UART Service (NUS)
BLECharacteristic txCharacteristic("6E400003-B5A3-F393-E0A9-E50E24DCCA9E", BLERead | BLENotify, 20);
BLECharacteristic rxCharacteristic("6E400002-B5A3-F393-E0A9-E50E24DCCA9E", BLEWrite, 20);

//Variables to declare which outputs to use. Bluetooth much cleaner than serial due to problems with ledc
int BluetoothEnabled = 1;
int SerialEnabled = 1;
int DebugEnabled = 1;
int VerboseEnabled = 1;


//----------------------------------------------------------------------------------

using namespace std;
using namespace rtos;
using namespace mbed;

//Sensors----------------------------------------------------------------------------
// I2C multiplexer and sensor addresses
#define MULTIPLEXER_ADDR 0xEE  // Multiplexer I2C address
#define SENSOR_ADDR 0x80       // Infrared sensor I2C address

// Sensor registers
#define DISTANCE_HIGH_REG 0x5E  // Register for high byte of distance data
#define SHIFT_BIT_REG 0x35      // Register for shift bit

// Multiplexer commands for selecting buses
#define MUX_BUS_0 0x01  // Bus 0
#define MUX_BUS_1 0x02  // Bus 1
#define MUX_BUS_2 0x04  // Bus 2
#define MUX_BUS_3 0x08  // Bus 3

// I2C pins for Nano 33 BLE (SCL and SDA)
#define SCL_PIN P0_31
#define SDA_PIN P0_2

// Instantiate the I2C object
I2C i2c(SCL_PIN, SDA_PIN);

#define US_PIN P0_23             // Define pin for both Trigger and Echo
DigitalInOut us_sensor(US_PIN);  // Use same pin for trigger and echo

void setMultiplexerBus(uint8_t busCommand);
float readDistanceCM();
void handleI2CError(int result);

volatile float distance_F1;
volatile float distance_F2;
volatile float distance_R1;
volatile float distance_R2;

volatile float distance_L;

//----------------------------------------------------------------------------------

//Motors----------------------------------------------------------------------------
// Define PWM pins for the motors
PwmOut motorA_pwm(P1_2);   // Motor 1 PWM pin
PwmOut motorB_pwm(P0_27);  // Motor 2 PWM pin

// Define direction control pins for the motors
DigitalOut motorA_dir(P0_4);  // Motor 1 direction pin
DigitalOut motorB_dir(P0_5);  // Motor 2 direction pin

// Define Encoder pins for Motor A and Motor B
InterruptIn encoderA(P1_12);
InterruptIn encoderB(P1_11);

bool TurnCheck = false;

// Define motor speed (between 0.0 and 1.0)
volatile float motor_speed = 0.0;

// Encoder variables for Motor A and Motor B
volatile int pulseCountA = 0;
volatile int pulseCountB = 0;
volatile int pulseCountDisA = 0;
volatile int pulseCountDisB = 0;
volatile int pulseCountA2 = 0;
volatile int pulseCountB2 = 0;
volatile int pulseCountDisA2 = 0;
volatile int pulseCountDisB2 = 0;
volatile float motorSpeedA = 0.0;      // Motor A speed
volatile float motorSpeedB = 0.0;      // Motor B speed
volatile float motorSpeedReadA = 0.0;  // Motor A speed measured in RPM
volatile float motorSpeedReadB = 0.0;  // Motor B speed measured in RPM

// Total distance traveled by each motor
volatile float distanceA = 0.0;
volatile float distanceB = 0.0;

volatile float avgDistance = (distanceA + distanceB) / 2.0;


// Encoder pulses per revolution (adjust to match your encoder's spec)
volatile float pulsesPerRevolutionA = 330.0;  // Motor A encoder PPR
volatile float pulsesPerRevolutionB = 330.0;  // Motor B encoder PPR

// Wheel parameters
volatile float turningCircle = 0.292;                                          // in cm
volatile float wheelDiameter = 0.0475;                                         // Example wheel diameter in meters (4.75 cm)
volatile float wheelCircumference = 3.14159 * wheelDiameter;                   // Circumference of the wheel
volatile float distancePerPulseA = wheelCircumference / pulsesPerRevolutionA;  // Distance per pulse for Motor A
volatile float distancePerPulseB = wheelCircumference / pulsesPerRevolutionB;  // Distance per pulse for Motor B

volatile int Equalized = 0;

Timer speedTimer;  // Timer to calculate motor speed every second
//----------------------------------------------------------------------------------

//Maze------------------------------------------------------------------------------
const int mazeWidth = 35;               //29
const int mazeHeight = 45;              //40
volatile float gridSize = 0.05;         //m
volatile float totalAvgDistance = 0.0;  // Total accumulated distance
int totalGridsMoved = 0;                // Count how many grids moved

int mazeMap[mazeHeight][mazeWidth];

// Robot's current position and direction
int robotX = 4;   //15;
int robotY = 40;  //20;
//int robotX = 2;
//int robotY = 37;
int robotDir = 0;  // 0= Up-North, 1= Right-East, 2= Down-South, 3= Left-West

int startX = 4, startY = 40;    // Starting position of the robot
int targetX = 17, targetY = 5;  // Destination


const int robotWidth = 3;
const int robotHeight = 3;
//----------------------------------------------------------------------------------

//Thread----------------------------------------------------------------------------

Thread MovementControlThread;
volatile bool runningMovementControl = true;

Thread SensorsThread;
volatile bool runningSensors = true;

Thread MappingThread;
volatile bool runningMapping = true;

Thread distanceThread;
volatile bool measureAvgDis = true;

void stopThreads() {
  runningMovementControl = false;
  MovementControlThread.join();

  runningSensors = false;
  SensorsThread.join();

  runningMapping = false;
  MappingThread.join();

  measureAvgDis = false;
  distanceThread.join();
}


/*void stopWallControlThread() {
  runningWallDistanceControl = false;  // Stop the thread when needed
  WallControlThread.join();            // Wait for the thread to finish
}


void startWallControlThread() {
  WallControlThread.start(maintainDistancefromRightWall);  // Start the thread
}

void startAvgDistanceThread() {
  distanceThread.start(measureAverageDistance);  // Start the distance measurement thread
}

void stopAvgDistanceThread() {
  measureAvgDis = false;
  distanceThread.join();
}*/

void measureAverageDistance() {
  while (measureAvgDis) {
    if (TurnCheck == false) {  // Only measure distance when not turning

      DistanceA();
      DistanceB();
      //float avgDistance = (distanceA + distanceB) / 2.0;

      totalAvgDistance += avgDistance;

      /*
      Serial.print("Avg Distance: ");
      Serial.println(avgDistance);
*/
      if (avgDistance >= gridSize) {
        // Update position
        robotX += dx(robotDir);
        robotY += dy(robotDir);
        totalGridsMoved++;

        Serial.println("Updated Position:");
        Serial.print("X: ");
        Serial.print(robotX);
        Serial.print(" Y: ");
        Serial.println(robotY);

        Serial.print("Total Grids Moved: ");
        Serial.println(totalGridsMoved);
        // Reset distances
        pulseCountDisA2 = 0;
        pulseCountDisB2 = 0;
        distanceA2 = 0;
        distanceB2 = 0;
      }
      /*
      Serial.print("Total Average Distance: ");
      Serial.println(totalAvgDistance);
      */
    }
    ThisThread::sleep_for(20ms);  // Adjust sampling rate
  }
}

//----------------------------------------------------------------------------------


//Djikstra--------------------------------------------------------------------------

struct Node {
  int x, y, cost;
  Node(int _x, int _y, int _cost)
    : x(_x), y(_y), cost(_cost) {}
};

void dijkstra(int startX, int startY, int targetX, int targetY) {
  queue<Node> q;
  q.push(Node(startX, startY, 0));

  while (!q.empty()) {
    Node curr = q.front();
    q.pop();

    int x = curr.x, y = curr.y;

    if (x == targetX && y == targetY) {
      // Found target
      return;
    }

    for (int i = 0; i < 4; i++) {
      int nx = x + dx(i), ny = y + dy(i);  // Call your dx() and dy() functions
      q.push(Node(nx, ny, curr.cost + 1));
    }
  }
}


bool canMove(int cx, int cy) {
  for (int i = -1; i <= 1; i++) {    // Check 3 rows
    for (int j = -1; j <= 1; j++) {  // Check 3 columns
      int nx = cx + i, ny = cy + j;
      if (nx < 0 || nx >= mazeHeight || ny < 0 || ny >= mazeWidth || mazeMap[nx][ny] == 1 || mazeMap[nx][ny] == -1) {
        return false;  // If any part of the 3×3 robot touches a wall, return false
      }
    }
  }
  return true;  // All 3×3 cells are free
}

void printMazePath(const vector<pair<int, int>>& path) {
  // Mark path on the maze with '2' (or any character you prefer)
  for (const auto& p : path) {
    mazeMap[p.first][p.second] = 2;
  }

  // Now print the maze with the path marked
  for (int i = 0; i < mazeHeight; i++) {
    for (int j = 0; j < mazeWidth; j++) {
      if (mazeMap[i][j] == 1) cout << "# ";        // Wall
      else if (mazeMap[i][j] == -1) cout << "? ";  // Unknown
      else if (mazeMap[i][j] == 2) cout << "• ";   // Path
      else cout << ". ";                           // Open space
    }
    cout << endl;
  }
}

//----------------------------------------------------------------------------------


bool wallAhead() {
  float avgFrontDistance = (distance_F1 + distance_F2) / 2.0;
  return avgFrontDistance <= 10.0;
}

bool gapOnRight() {
  return abs(distance_R1 - distance_R2) >= 15.0;
}


void decisionMaker() {
  if (wallAhead() && gapOnRight()) {
    // Wall ahead and gap on the right -> Turn right
    //turnRight();
  } else if (wallAhead() && !gapOnRight()) {
    // Wall ahead and no gap on the right -> Call alignment function & turn left or stop
    //alignToWall();  // Align itself 10 cm away

  } else if (!wallAhead() && gapOnRight()) {
    // No wall ahead and gap on the right -> Turn right (follow wall)
    //turnRight();
  } else if (!wallAhead() && !gapOnRight()) {
    // No wall ahead and no gap on the right -> Continue straight
    //moveForward();
  }
}




void handleI2CError(int result) {
  if (result != 0) {
    Serial.print("I2C Error: ");
    Serial.println(result);
  }
}

// Function to set the multiplexer to a specific bus
void setMultiplexerBus(uint8_t busCommand) {
  int result = i2c.write(MULTIPLEXER_ADDR, reinterpret_cast<char*>(&busCommand), 1);
  handleI2CError(result);
}

// Function to read and calculate the distance in cm
float readDistanceCM() {
  char cmd;                 // Command for register access
  char rawData[2] = { 0 };  // Array to store raw sensor data
  char shiftBit = 0;        // Shift bit for scaling

  // Step 1: Read the shift bit from the sensor
  cmd = SHIFT_BIT_REG;
  i2c.write(SENSOR_ADDR, &cmd, 1);
  delay(1);  // Allow the sensor time to process the command

  i2c.read(SENSOR_ADDR, &shiftBit, 1);

  // Step 2: Read the raw distance data (2 bytes)
  cmd = DISTANCE_HIGH_REG;
  i2c.write(SENSOR_ADDR, &cmd, 1);

  delay(1);

  i2c.read(SENSOR_ADDR, rawData, 2);

  // Step 3: Combine high and low bytes into a single value
  uint16_t distance_R2aw = (rawData[0] << 8) | rawData[1];  // (rawData[0]*16 + rawData[1])/16/pow(2,2)

  // Step 4: Calculate the distance in cm using the shift bit
  float distanceCM = (rawData[0] * 16 + rawData[1]) / 16 / pow(2, 2);  //distance_R2aw / pow(2, shiftBit);

  return distanceCM;
}

// Function to measure distance
void USDistance_L() {
  Timer timer;
  float duration;

  // Set pin as output to send trigger pulse
  us_sensor.output();
  us_sensor = 0;  // Ensure LOW before triggering
  wait_us(2);
  us_sensor = 1;  // Trigger pulse
  wait_us(10);
  us_sensor = 0;

  // Switch pin to input to read echo
  us_sensor.input();

  // Wait for echo HIGH with timeout
  int timeout = 30000;  // 30ms timeout
  while (us_sensor == 0 && timeout > 0) {
    wait_us(1);
    timeout--;
  }
  if (timeout <= 0) {
    Serial.println("Timeout waiting for echo HIGH");
    distance_L = -1.0f;  // Indicate failure
    return;
  }

  // Start timer when echo goes HIGH
  timer.start();

  // Wait for echo LOW with timeout
  timeout = 30000;  // Reset timeout
  while (us_sensor == 1 && timeout > 0) {
    wait_us(1);
    timeout--;
  }
  timer.stop();

  if (timeout <= 0) {
    Serial.println("Timeout waiting for echo LOW");
    distance_L = -1.0f;  // Indicate failure
    return;
  }

  // Get elapsed time in microseconds
  duration = timer.elapsed_time().count();

  // Calculate distance (speed of sound = 34300 cm/s)
  distance_L = (duration * 0.0343f) / 2.0f;

  // Subtract 1 cm from the measured distance
  distance_L -= 1.0f;  // Now distance_L is reduced by 1 cm
}

void checksensors() {
  while (runningSensors) {
    setMultiplexerBus(MUX_BUS_0);
    distance_F1 = readDistanceCM();
    ThisThread::sleep_for(20ms);  // Non-blocking sleep for 20ms

    setMultiplexerBus(MUX_BUS_1);
    distance_F2 = readDistanceCM();
    ThisThread::sleep_for(20ms);  // Non-blocking sleep for 20ms

    setMultiplexerBus(MUX_BUS_2);
    distance_R1 = readDistanceCM();
    ThisThread::sleep_for(20ms);  // Non-blocking sleep for 20ms

    setMultiplexerBus(MUX_BUS_3);
    distance_R2 = readDistanceCM();
    ThisThread::sleep_for(20ms);  // Non-blocking sleep for 20ms

    USDistance_L();
    ThisThread::sleep_for(20ms);  // Non-blocking sleep for 20ms
  }
}

void checksensorscheck() {

  Serial.print("Sensor F1 Distance: ");
  Serial.print(distance_F1);
  Serial.println(" cm");

  delay(50);  // 500 ms delay

  Serial.print("Sensor F2 Distance: ");
  Serial.print(distance_F2);
  Serial.println(" cm");

  delay(50);  // 500 ms delay

  Serial.print("Sensor R1 Distance: ");
  Serial.print(distance_R1);
  Serial.println(" cm");

  delay(50);  // 500 ms delay

  Serial.print("Sensor R2 Distance: ");
  Serial.print(distance_R2);
  Serial.println(" cm");

  delay(50);  // 500 ms delay

  Serial.print("Sensor L Distance: ");
  Serial.print(distance_L);
  Serial.println(" cm");

  delay(50);  // 500 ms delay
}

/*void sendSensorData() {
  String data = "F1:" + String(distance_F1) + "cm" + "F2:" + String(distance_F2) + "cm" + "R1:" + String(distance_R1) + "cm" + "R2:" + String(distance_R2) + "cm" + "L1:" + String(distance_L) + "cm";

  // Convert String to C-string
  const char* sensorData = data.c_str();
  int length = strlen(sensorData);

  // Send data in chunks (max 10 bytes per packet)
  for (int i = 0; i < length; i += 10) {
    String chunk = data.substring(i, i + 10);    // Extract 10-character chunk
    txCharacteristic.writeValue(chunk.c_str());  // Send chunk via BLE
    delay(50);                                   // Small delay to ensure data is transmitted properly
  }

  Serial.println("Sent sensor data over BLE: " + data);
}*/

void Debug(String Message, bool Verbose) {
  if (DebugEnabled) {
    if (Verbose) {
      if (VerboseEnabled) {
        if (SerialEnabled) {
          Serial.print(Message);
        }
        if (BluetoothEnabled) {
          txCharacteristic.writeValue(Message.c_str());  // Send message via BLE
        }
      }
    } else {
      if (SerialEnabled) {
        Serial.print(Message);
      }
      if (BluetoothEnabled) {
        txCharacteristic.writeValue(Message.c_str());  // Buffer message for BLE
      }
    }
  }
}


void DebugLn(String MessageLn, bool Verbose) {
  if (DebugEnabled) {
    if (Verbose) {
      if (VerboseEnabled) {
        if (SerialEnabled) {
          Serial.println(MessageLn);
        }
        if (BluetoothEnabled) {
          String messageWithNewline = MessageLn + "\n";  // Append newline for BLE consistency
          txCharacteristic.writeValue(messageWithNewline.c_str());
        }
      }
    } else {
      if (SerialEnabled) {
        Serial.println(MessageLn);
      }
      if (BluetoothEnabled) {
        String messageWithNewline = MessageLn + "\n";  // Append newline for BLE consistency
        txCharacteristic.writeValue(messageWithNewline.c_str());
      }
    }
  }
}


//volatile float wallThreshold = 10.0;  // Wall detection threshold in cm

void initializeMazeMap() {
  // Set all cells to unknown (-1)
  for (int y = 0; y < mazeHeight; y++) {
    for (int x = 0; x < mazeWidth; x++) {
      mazeMap[y][x] = -1;  // -1 represents unknown
    }
  }
}

void displayMazeMap() {
  Serial.println("Current Maze Map:");
  for (int y = 0; y < mazeHeight; y++) {
    for (int x = 0; x < mazeWidth; x++) {
      if (mazeMap[y][x] == 1) {
        Serial.print(" W ");  // Wall
      } else if (mazeMap[y][x] == -1) {
        Serial.print(" # ");  // Unknown
      } else if (mazeMap[y][x] == 0) {
        Serial.print(" . ");  // Empty space
      } else if (mazeMap[y][x] == 3) {
        Serial.print(" R ");  // Robot body
      } else if (mazeMap[y][x] == 2) {
        // Represent the robot's center with directional arrows
        if (robotDir == 0) {
          Serial.print(" ↑ ");  // Facing Up
        } else if (robotDir == 1) {
          Serial.print(" → ");  // Facing Right
        } else if (robotDir == 2) {
          Serial.print(" ↓ ");  // Facing Down
        } else if (robotDir == 3) {
          Serial.print(" ← ");  // Facing Left
        }
      }
    }
    Serial.println();  // Move to the next row
  }
  Serial.println();  // Add an extra newline for readability
}

void displayMazeMapOverBLE() {
  String mazeStr = "";

  // Convert the maze map into a string to send over BLE
  for (int y = 0; y < mazeHeight; y++) {
    String rowStr = "";
    for (int x = 0; x < mazeWidth; x++) {
      if (mazeMap[y][x] == 1) {
        mazeStr += "W";  // Wall
      } else if (mazeMap[y][x] == -1) {
        mazeStr += "#";  // Unknown
      } else if (mazeMap[y][x] == 0) {
        mazeStr += ".";  // Empty space
      } else if (mazeMap[y][x] == 3) {
        mazeStr += "R";  // Robot body
      } else if (mazeMap[y][x] == 2) {
        // Represent the robot's center with directional arrows
        if (robotDir == 0) {
          mazeStr += "↑";  // Facing Up
        } else if (robotDir == 1) {
          mazeStr += "→";  // Facing Right
        } else if (robotDir == 2) {
          mazeStr += "↓";  // Facing Down
        } else if (robotDir == 3) {
          mazeStr += "←";  // Facing Left
        }
      }
      // Ensure each row has exactly 35 characters
      while (rowStr.length() < 35) {
        rowStr += " ";  // Pad with spaces if needed
      }
    }
    mazeStr += "\n";  // New line for each row
  }

  // Convert String to const char* and send it over BLE in chunks (max 20 bytes per packet)
  const char* mazeData = mazeStr.c_str();  // Convert String to const char*
  int length = strlen(mazeData);           // Get the length of the C-string

  for (int i = 0; i < length; i += 35) {
    String chunk = String(mazeData).substring(i, i + 35);  // Get a chunk of the maze data
    txCharacteristic.writeValue(chunk.c_str());            // Send the chunk via BLE
    delay(100);                                            // Small delay to ensure data is transmitted correctly
  }

  Serial.println("Maze sent over BLE!");
}

void updateMazeMap() {
  // Mark all the cells occupied by the robot as empty (0)
  //for (int i = 0; i < robotHeight; i++) {
  //for (int j = 0; j < robotWidth; j++) {
  for (int i = -1; i <= 1; i++) {  // Offset for the 3x3 grid
    for (int j = -1; j <= 1; j++) {

      int surroundingX = robotX + j;
      int surroundingY = robotY + i;

      // Ensure the grid coordinates are within bounds
      if (surroundingX >= 0 && surroundingX < mazeWidth && surroundingY >= 0 && surroundingY < mazeHeight) {
        mazeMap[surroundingY][surroundingX] = 3;  // Robot

        Serial.print("Marked grid at (");
        Serial.print(surroundingX);
        Serial.print(", ");
        Serial.print(surroundingY);
        Serial.println(") as empty.");
      }
    }
  }
  // Mark the robot's center position as 'X'
  if (robotX >= 0 && robotX < mazeWidth && robotY >= 0 && robotY < mazeHeight) {
    mazeMap[robotY][robotX] = 2;  // Use 2 to represent the robot in the map
  }

  // Display robot's new position
  Serial.print("Robot's position marked at: (");
  Serial.print(robotX);
  Serial.print(", ");
  Serial.print(robotY);
  Serial.println(") as 'X'.");
}

void processSensorData(float sensorDistance, int startX, int startY, int dx, int dy, bool) {
  const int maxDistanceCm = 50;  // Maximum distance to consider
  const int gridSizeCm = 5;      // Size of each grid cell in cm
  int offset = 1;                // Physical sesnsor offset


  // Convert distance to grid cells
  int maxGridSpaces = maxDistanceCm / gridSizeCm;  // Max grid spaces (50 cm = 10 grids)
  int freeSpaces = min(sensorDistance / gridSizeCm, maxGridSpaces);

  // Mark free spaces
  for (int i = 1; i <= freeSpaces; i++) {  // Start from 1 to skip the robot's position
    int gridX = startX + i * dx;
    int gridY = startY + i * dy;

    // Ensure within maze bounds
    if (gridX >= 0 && gridX < mazeWidth && gridY >= 0 && gridY < mazeHeight) {
      mazeMap[gridY][gridX] = 0;  // Mark as free space
    }
  }

  // Mark the wall (if within bounds)
  if (freeSpaces < maxGridSpaces) {  // Only mark a wall if there's a limit
    int wallX = startX + (freeSpaces + offset) * dx;
    int wallY = startY + (freeSpaces + offset) * dy;

    if (wallX >= 0 && wallX < mazeWidth && wallY >= 0 && wallY < mazeHeight) {
      mazeMap[wallY][wallX] = 1;  // Mark as wall
    }
  }
}

void checkSensorsAndUpdateMaze() {  //scans surroundings using sensors
  // Sensor threshold for detecting walls
  float Threshold = 50.0;     // Adjust as per environment (in cm)
  int maxDistanceCells = 10;  // Maximum grid cells to mark free

  // Directions for the robot's facing direction
  int forwardDx = dx(robotDir);  // X direction for facing forward
  int forwardDy = dy(robotDir);  // Y direction for facing forward
  int leftDx = dy(robotDir);     // X direction for left of facing
  int leftDy = -dx(robotDir);    // Y direction for left of facing
  int rightDx = -dy(robotDir);   // X direction for right of facing
  int rightDy = dx(robotDir);    // Y direction for right of facing

  // Compute sensor positions relative to the robot
  int F1_startX = robotX + leftDx + forwardDx;  // F1 is one grid left and forward
  int F1_startY = robotY + leftDy + forwardDy;
  int F2_startX = robotX + rightDx + forwardDx;  // F2 is one grid right and forward
  int F2_startY = robotY + rightDy + forwardDy;
  int R1_startX = robotX + forwardDx + rightDx;  // R1 is one grid forward and right
  int R1_startY = robotY + forwardDy + rightDy;
  int R2_startX = robotX - forwardDx + rightDx;  // R2 is one grid backward and right
  int R2_startY = robotY - forwardDy + rightDy;
  int L_startX = robotX + leftDx;  // L is one grid left and forward
  int L_startY = robotY + leftDy;

  // Process the front-left sensor (F1)
  if (distance_F1 < Threshold) {
    Serial.print(distance_F1);
    Serial.println("Wall detected by F1.");
    processSensorData(distance_F1, F1_startX, F1_startY, forwardDx, forwardDy, true);
  } else {
    Serial.println("No wall detected by F1.");
    processSensorData(distance_F1, F1_startX, F1_startY, forwardDx, forwardDy, false);
  }

  // Process the front-right sensor (F2)
  if (distance_F2 < Threshold) {
    Serial.print(distance_F2);
    Serial.println("Wall detected by F2.");
    processSensorData(distance_F2, F2_startX, F2_startY, forwardDx, forwardDy, true);
  } else {
    Serial.println("No wall detected by F2.");
    processSensorData(distance_F2, F2_startX, F2_startY, forwardDx, forwardDy, false);
  }

  if (distance_R1 < Threshold) {
    Serial.print(distance_R1);
    Serial.println("Wall detected by R1.");
    processSensorData(distance_R1, R1_startX, R1_startY, rightDx, rightDy, true);
  } else {
    Serial.println("No wall detected by R1.");
    processSensorData(distance_R1, R1_startX, R1_startY, rightDx, rightDy, false);
  }

  // Process the right sensor (R)
  if (distance_R2 < Threshold) {
    Serial.print(distance_R2);
    Serial.println("Wall detected by R2.");
    processSensorData(distance_R2, R2_startX, R2_startY, rightDx, rightDy, true);
  } else {
    Serial.println("No wall detected by R2.");
    processSensorData(distance_R2, R2_startX, R2_startY, rightDx, rightDy, false);
  }

  // Process the left sensor (L)
  if (distance_L < Threshold) {
    Serial.print(distance_L);
    Serial.println("Wall detected by L.");
    processSensorData(distance_L, L_startX, L_startY, leftDx, leftDy, true);
  } else {
    Serial.println("No wall detected by L.");
    processSensorData(distance_L, L_startX, L_startY, leftDx, leftDy, false);
  }

  Serial.print("Front 1 Sensor Distance: ");
  Serial.print(distance_F1);
  Serial.println(" cm");

  Serial.print("Front 2 Sensor Distance: ");
  Serial.print(distance_F2);
  Serial.println(" cm");



  Serial.print("Right 1 Sensor Distance: ");
  Serial.print(distance_R1);
  Serial.println(" cm");

  Serial.print("Right 2 Sensor Distance: ");
  Serial.print(distance_R2);
  Serial.println(" cm");

  Serial.print("Left Sensor Distance: ");
  Serial.print(distance_L);
  Serial.println(" cm");
}

void smartMapUnknowns() {
  for (int y = 1; y < mazeHeight - 1; y++) {
    for (int x = 1; x < mazeWidth - 1; x++) {
      if (mazeMap[y][x] == -1 || mazeMap[y][x] == 0) {  // If the cell is unknown
        // Check if the unknown cell is surrounded by walls on the same row (y-axis)
        if (mazeMap[y][x - 1] == 1 && mazeMap[y][x + 1] == 1) {
          mazeMap[y][x] = 1;  // Mark as wall
          clearPathToWall(robotX, robotY, x, y);
        }
        // Check if the unknown cell is surrounded by walls on the same column (x-axis)
        if (mazeMap[y - 1][x] == 1 && mazeMap[y + 1][x] == 1) {
          mazeMap[y][x] = 1;  // Mark as wall
          clearPathToWall(robotX, robotY, x, y);
        }
      }
    }
  }
}

void clearPathToWall(int startX, int startY, int endX, int endY) {
  // Check if the path is horizontal or vertical
  if (startX == endX) {  // Vertical path
    int minY = min(startY, endY);
    int maxY = max(startY, endY);
    for (int y = minY + 1; y < maxY; y++) {  // Avoid marking the robot's position or the wall itself
      if (mazeMap[y][startX] == -1) {        // Mark as free space if it was unknown
        mazeMap[y][startX] = 0;              // Free space
      }
    }
  } else if (startY == endY) {  // Horizontal path
    int minX = min(startX, endX);
    int maxX = max(startX, endX);
    for (int x = minX + 1; x < maxX; x++) {  // Avoid marking the robot's position or the wall itself
      if (mazeMap[startY][x] == -1) {        // Mark as free space if it was unknown
        mazeMap[startY][x] = 0;              // Free space
      }
    }
  }
}


/*
void MovementMapping() {
  while (runningMapping) {
    if (Moving == false) {
      //if (TurnCheck == false) {
      // Store the robot's last known state
      static int lastRobotX = robotX;
      static int lastRobotY = robotY;
      static int lastRobotDir = robotDir;

      bool hasMoved = false;
      bool hasTurned = false;


      // Check if the robot moved to a new grid cell
      if (robotX != lastRobotX || robotY != lastRobotY) {
        Serial.println("Robot moved. Scanning the maze.");
        hasMoved = true;
        lastRobotX = robotX;
        lastRobotY = robotY;
      }



      if (TurnCheck != true) {
        // Check if the robot turned to a new direction
        if (robotDir != lastRobotDir) {
          Serial.println("Robot turned. Scanning the maze.");
          hasTurned = true;
          lastRobotDir = robotDir;

        } else if (hasTurned != true) {
          // If the robot is NOT turning, calculate movement
          DistanceA();
          DistanceB();
          float avgDistance = (distanceA + distanceB) / 2.0;
          if (avgDistance >= gridSize && robotDir == lastRobotDir) {
            // Update position
            robotX += dx(robotDir);
            robotY += dy(robotDir);

            Serial.println("Updated Position:");
            Serial.print("X: ");
            Serial.print(robotX);
            Serial.print(" Y: ");
            Serial.println(robotY);

            // Reset distances
            pulseCountDisA = 0;
            pulseCountDisB = 0;
            distanceA = 0;
            distanceB = 0;

            hasMoved = true;
          }
        }
      }
      // If the robot moved or turned, update the maze
      if (hasMoved || hasTurned) {
        updateMazeMap();              // Update the maze with the current robot position
        checkSensorsAndUpdateMaze();  // Scan and update maze walls or obstacles
        //displayMazeMap();
      }
    }
  }
  ThisThread::sleep_for(100ms);  // Non-blocking sleep for 20ms
}*/

void MovementMapping() {
  while (runningMapping) {
    // Store the robot's last known state
    static int lastRobotX = robotX;
    static int lastRobotY = robotY;
    static int lastRobotDir = robotDir;

    bool hasMoved = false;
    bool hasTurned = false;

    // Check if the robot moved to a new grid cell
    if (robotX != lastRobotX || robotY != lastRobotY) {
      Serial.println("Robot moved. Scanning the maze.");
      hasMoved = true;
      lastRobotX = robotX;
      lastRobotY = robotY;
    }

    // Check if the robot turned to a new direction
    if (robotDir != lastRobotDir) {
      Serial.println("Robot turned. Scanning the maze.");
      hasTurned = true;
      lastRobotDir = robotDir;
    }

    // If the robot moved or turned, update the maze
    if (hasMoved || hasTurned) {
      updateMazeMap();              // Update the maze with the current robot position
      checkSensorsAndUpdateMaze();  // Scan and update maze walls or obstacles
      //displayMazeMap();             // Optional: Display the updated maze
    }
  }
}


int dx(int direction) {
  // Determine how to move in the X direction based on the robot's orientation
  if (direction == 1) {
    return 1;  // Move right, East
  } else if (direction == 3) {
    return -1;  // Move left, West
  }
  return 0;  // No movement in X
}

int dy(int direction) {
  // Determine how to move in the Y direction based on the robot's orientation
  if (direction == 0) {
    return -1;  // Move up, North
  } else if (direction == 2) {
    return 1;  // Move down, South
  }
  return 0;  // No movement in Y
}

/*void markAsWall(int x, int y) {
  // Mark the cells occupied by the robot as walls (1)
  for (int i = 0; i < robotHeight; i++) {
    for (int j = 0; j < robotWidth; j++) {
      int gridX = x + j;
      int gridY = y + i;

      // Ensure the grid coordinates are within bounds
      if (gridX >= 0 && gridX < mazeWidth && gridY >= 0 && gridY < mazeHeight) {
        mazeMap[gridY][gridX] = 1;  // Wall
        Serial.print("Marked grid at (");
        Serial.print(gridX);
        Serial.print(", ");
        Serial.print(gridY);
        Serial.println(") as a wall.");
      }
    }
  }
}

void markAsUnknown(int x, int y) {
  // Mark the cells occupied by the robot as unknown (-1)
  for (int i = 0; i < robotHeight; i++) {
    for (int j = 0; j < robotWidth; j++) {
      int gridX = x + j;
      int gridY = y + i;

      // Ensure the grid coordinates are within bounds
      if (gridX >= 0 && gridX < mazeWidth && gridY >= 0 && gridY < mazeHeight) {
        mazeMap[gridY][gridX] = -1;  // Unknown
        Serial.print("Marked grid at (");
        Serial.print(gridX);
        Serial.print(", ");
        Serial.print(gridY);
        Serial.println(") as unknown.");
      }
    }
  }
}
*/

// Interrupt handler for encoder A (Motor A)
void encoderISR_A() {
  pulseCountA++;
  pulseCountDisA++;
    pulseCountDisA2++;
}

// Interrupt handler for encoder B (Motor B)
void encoderISR_B() {
  pulseCountB++;
  pulseCountDisB++;
    pulseCountDisB2++;

}

void setup() {

  Serial.begin(9600);
  while (!Serial)
    ;

  if (!BLE.begin()) {
    Serial.println("Failed to initialize BLE!");
    while (1)
      ;
  }

  BLE.setLocalName("Cal-BT");
  BLE.setAdvertisedService(uartService);

  uartService.addCharacteristic(txCharacteristic);
  uartService.addCharacteristic(rxCharacteristic);
  BLE.addService(uartService);

  BLE.advertise();
  Serial.println("BLE UART Ready. Open Bluefruit Connect App.");

  // Initialize Serial communication at 9600 baud rate
  Serial.begin(9600);
  Serial.println("Serial communication started.");

  // Set PWM period (optional, depending on motor driver requirements)
  motorA_pwm.period(0.001);  // Set PWM period to 1 ms for motor 1
  motorB_pwm.period(0.001);  // Set PWM period to 1 ms for motor 2

  // Set motor directions
  motorA_dir = 1;  // Set motor 1 to forward direction
  motorB_dir = 0;  // Set motor 2 to reverse direction

  // Set motor speeds
  motorA_pwm.write(motor_speed);  // Set speed for motor 1
  motorB_pwm.write(motor_speed);  // Set speed for motor 2

  // Attach interrupts for encoder signals
  encoderA.fall(&encoderISR_A);  // Interrupt on falling edge of Motor A encoder
  encoderB.fall(&encoderISR_B);  // Interrupt on falling edge of Motor B encoder

  // Start timer for speed calculation
  speedTimer.start();

  SensorsThread.start(checksensors);

  MappingThread.start(MovementMapping);

  distanceThread.start(measureAverageDistance);


  initializeMazeMap();

  Mapsetup();

  //alignRobot();

  //setStartPosition(15, 20);
}

void Mapsetup() {
  checkSensorsAndUpdateMaze();
  updateMazeMap();
  displayMazeMap();
  displayMazeMapOverBLE();
}

void setStartPosition(int startX, int startY) {
  robotX = startX;
  robotY = startY;

  // Update the map to reflect the robot's starting position
  mazeMap[startY][startX] = 0;  // Mark as visited or free space
  Serial.print("Robot starting position set to: (");
  Serial.print(robotX);
  Serial.print(", ");
  Serial.print(robotY);
  Serial.println(")");

  displayMazeMap();  // Print the updated maze
}

void alignRobot() {
  // Step 1: Align to the front (5 cm from the front wall)
  alignFrontt();

  // Step 2: Turn 90 degrees right
  turnfourtyfiveright();

  delay(200);

  turnfourtyfiveright();
  // Step 3: Align to the new front (after turning, it is the previous right side)
  alignFrontt();

  // Step 4: Turn 90 degrees right again
  turnfourtyfiveright();

  delay(200);

  turnfourtyfiveright();
}

void alignFrontt() {

  // First, check the distance to the front wall
  while (distance_F1 > 0.10) {  // If the front sensor is further than 5 cm, move forward
    forward();                  // Move forward
    motorSpeedA = 0.3;
    motorSpeedB = 0.3;
    equalizeMotor();
    DistanceA();  // Update the distance for Motor A
    DistanceB();  // Update the distance for Motor B
    delay(100);   // Adjust the delay based on how fast you want to move
  }


  while (distance_F1 < 0.10) {  // If the front sensor is less than 5 cm, move backward
    reverse();

    motorSpeedA = 0.2;
    motorSpeedB = 0.2;

    equalizeMotor();

    DistanceA();  // Update the distance for Motor A
    DistanceB();  // Update the distance for Motor B

    delay(100);  // Adjust the delay based on how fast you want to move

    Serial.println("Front alignment complete.");
  }
}

void alignFrontWithTwoSensors1() {
  const float targetDistance = 10.0;
  const float distanceTolerance = 0.05;
  const float alignmentTolerance = 0.01;
  const float adjustment = 0.01;
  //const float slowSpeed = 0.1;

  while (true) {


    // Read distances from the two front sensors
    //float frontLeftDistance = getFrontLeftSensor();    // Replace with actual function to read sensor
    //float frontRightDistance = getFrontRightSensor();  // Replace with actual function to read sensor

    // Calculate average distance to the wall
    float averageDistance = (distance_F1 + distance_F2) / 2;

    // Check for alignment
    float sensorAlignmentDifference = distance_F1 - distance_F2;

    if (abs(sensorAlignmentDifference) <= alignmentTolerance) {
      // If the difference is within the threshold, alignment is complete
      motorSpeedA = 0.2;
      motorSpeedB = 0.2;
      Serial.println(sensorAlignmentDifference);
      Serial.print("Front Left Distance: ");
      Serial.print(distance_F1);
      Serial.println(" cm");
      Serial.print("Front Right Distance: ");
      Serial.print(distance_F2);
      Serial.println(" cm");
      Serial.print("Average Distance: ");
      Serial.print(averageDistance);
      Serial.println(" cm");
      // Stop the motors and exit the alignment loop
      brake();
      Serial.println("Front wall alignment complete.");
      break;
    } else if (sensorAlignmentDifference > distanceTolerance) {
      Serial.println(sensorAlignmentDifference);
      Serial.print("Front Left Distance: ");
      Serial.print(distance_F1);
      Serial.println(" cm");
      Serial.print("Front Right Distance: ");
      Serial.print(distance_F2);
      Serial.println(" cm");
      Serial.print("Average Distance: ");
      Serial.print(averageDistance);
      Serial.println(" cm");
      // Left side is farther; adjust left motor
      //motorSpeedA = baseSpeed;  // Keep right motor at base speed
      motorSpeedB = min(motorSpeedB + adjustment, 0.2);  // Increase left motor speed
    } else if (sensorAlignmentDifference < -distanceTolerance) {
      Serial.println(sensorAlignmentDifference);

      // Right side is farther; adjust right motor
      motorSpeedA = min(motorSpeedA + adjustment, 0.2);  // Increase right motor speed
      //motorSpeedB = baseSpeed;  // Keep left motor at base speed
    }

    // Debugging output for motor speeds
    Serial.print("Motor Speed A: ");
    Serial.println(motorSpeedA);
    Serial.print("Motor Speed B: ");
    Serial.println(motorSpeedB);

    // Write motor speeds to the motors
    motorA_pwm.write(motorSpeedA);
    motorB_pwm.write(motorSpeedB);

    // Check if robot is within the target range
    if (distance_F1 > targetDistance + distanceTolerance || distance_F2 > targetDistance + distanceTolerance) {
      //if (averageDistance > targetDistance + distanceTolerance) {
      forward();  // Move forward
      motorSpeedA = 0.2;
      motorSpeedB = 0.2;
      Serial.print("Front Left Distance: ");
      Serial.print(distance_F1);
      Serial.println(" cm");
      Serial.print("Front Right Distance: ");
      Serial.print(distance_F2);
      Serial.println(" cm");
    } else if (distance_F1 < targetDistance - distanceTolerance || distance_F2 < targetDistance - distanceTolerance) {
      //} else if (averageDistance < targetDistance - distanceTolerance) {
      reverse();  // Move backward
      motorSpeedA = 0.2;
      motorSpeedB = 0.2;
      Serial.print("Front Left Distance: ");
      Serial.print(distance_F1);
      Serial.println(" cm");
      Serial.print("Front Right Distance: ");
      Serial.print(distance_F2);
      Serial.println(" cm");
    } else {
      brake();  // Stop the robot
      //Serial.println("Front alignment complete.");
    }


    delay(50);
  }
}

void alignFrontWithTwoSensors2() {
  const float targetDistance = 5.0;       // Final target distance in cm
  const float distanceTolerance = 0.05;   // Tolerance for distance to target
  const float alignmentTolerance = 0.01;  // Tolerance for alignment
  const float adjustment = 0.2;           // Speed for alignment adjustments
  //const float slowSpeed = 0.1; // Slow speed for fine adjustments

  while (true) {

    // Calculate average distance to the wall
    float averageDistance = (distance_F1 + distance_F2) / 2;

    // Debugging output
    Serial.print("Front Left Distance: ");
    Serial.print(distance_F1);
    Serial.println(" cm");
    Serial.print("Front Right Distance: ");
    Serial.print(distance_F2);
    Serial.println(" cm");
    Serial.print("Average Distance: ");
    Serial.print(averageDistance);
    Serial.println(" cm");

    // Check for alignment
    float sensorAlignmentDifference = distance_F1 - distance_F2;

    if (abs(sensorAlignmentDifference) <= alignmentTolerance) {
      // If aligned, check target distance
      if (abs(averageDistance - targetDistance) <= distanceTolerance) {
        // Target distance reached, stop and break
        brake();
        Serial.println("Alignment complete at target distance.");
        break;
      } else if (averageDistance > targetDistance) {
        // Move forward if too far
        motorSpeedA = 0.2;
        motorSpeedB = 0.2;
        forward();
        Serial.println("Moving forward to target distance.");
      } else if (averageDistance < targetDistance) {
        // Move backward if too close
        motorSpeedA = 0.2;
        motorSpeedB = 0.2;
        reverse();
        Serial.println("Moving backward to target distance.");
      }
    } else {
      if (abs(sensorAlignmentDifference) <= alignmentTolerance) {
        // Alignment is within tolerance, stop the motors
        motorSpeedA = 0;
        motorSpeedB = 0;
        brake();  // Stop both motors
        Serial.println("Alignment within tolerance. Stopping adjustment.");
      } else {
        // Adjust motors for alignment (one motor at a time)
        if (sensorAlignmentDifference > alignmentTolerance) {
          // Left side is farther; move only the left motor backward
          motorSpeedA = min(motorSpeedB + adjustment, 0.25);  // Increase left motor speed
          motorSpeedB = 0;                                    // Stop the right motor
          Serial.println("Adjusting alignment: Moving left motor.");
        } else {
          // Right side is farther; move only the right motor backward
          motorSpeedA = 0;                                    // Stop the left motor
          motorSpeedB = min(motorSpeedB + adjustment, 0.25);  // Increase left motor speed
          Serial.println("Adjusting alignment: Moving right motor.");
        }
      }
    }

    // Debugging output for motor speeds
    Serial.print("Motor Speed A: ");
    Serial.println(motorSpeedA);
    Serial.print("Motor Speed B: ");
    Serial.println(motorSpeedB);

    // Write motor speeds to the motors
    motorA_pwm.write(motorSpeedA);
    motorB_pwm.write(motorSpeedB);

    delay(50);  // Short delay for stabilization
  }
}

void alignFrontWithTwoSensors3() {
  const float initialTargetDistance = 6.0;  // Move to 6 cm first
  const float finalTargetDistance = 5.5;    // Then fine-tune to 5 cm
  const float distanceTolerance = 0.5;      // Tolerance for reaching 6 cm
  const float alignmentTolerance = 0.1;     // Tolerance for final alignment
  const float moveSpeed = 0.2;              // Speed for moving to 6 cm
  const float fineAdjustSpeed = 0.1;        // Slow speed for final alignment
  bool reachedInitialTarget = false;        // Flag for transitioning to fine-tuning

  while (true) {
    float averageDistance = (distance_F1 + distance_F2) / 2.0;
    float sensorAlignmentDifference = distance_F1 - distance_F2;

    // Debugging output
    Serial.print("Front Left Distance: ");
    Serial.println(distance_F1);
    Serial.print("Front Right Distance: ");
    Serial.println(distance_F2);
    Serial.print("Average Distance: ");
    Serial.println(averageDistance);

    // Step 1: Move toward an average distance of 6 cm
    if (!reachedInitialTarget) {
      if (abs(averageDistance - initialTargetDistance) > distanceTolerance) {
        if (averageDistance > initialTargetDistance) {
          Serial.println("Moving forward to 6 cm...");
          motorSpeedA = moveSpeed;
          motorSpeedB = moveSpeed;
          forward();
        } else {
          Serial.println("Moving backward to 6 cm...");
          motorSpeedA = moveSpeed;
          motorSpeedB = moveSpeed;
          reverse();
        }
      } else {
        Serial.println("Reached 6 cm. Switching to fine-tuning mode.");
        reachedInitialTarget = true;
        brake();
        delay(500);  // Small pause before fine-tuning
      }
    }
    // Step 2: Fine-tune each sensor to exactly 5 cm by moving forward while swiveling
    else {
      Serial.println("Fine-tuning alignment...");
      if (distance_F1 > finalTargetDistance || distance_F2 > finalTargetDistance) {
        if (distance_F1 > distance_F2) {
          // Left sensor is farther → Move left motor forward slightly
          Serial.println("Adjusting: Moving Left Motor Forward");
          motorSpeedA = fineAdjustSpeed;
          motorSpeedB = 0;
        } else if (distance_F2 > distance_F1) {
          // Right sensor is farther → Move right motor forward slightly
          Serial.println("Adjusting: Moving Right Motor Forward");
          motorSpeedA = 0;
          motorSpeedB = fineAdjustSpeed;
        } else {
          // Both sensors are close to target → Move both forward slightly
          Serial.println("Final Move: Bringing both sensors to 5 cm...");
          motorSpeedA = fineAdjustSpeed;
          motorSpeedB = fineAdjustSpeed;
          forward();
        }
      } else {
        // Stop when fully aligned
        Serial.println("Fully aligned at 5 cm! Stopping.");
        motorSpeedA = 0;
        motorSpeedB = 0;
        brake();
        break;
      }
    }

    // Apply motor speeds
    motorA_pwm.write(motorSpeedA);
    motorB_pwm.write(motorSpeedB);

    delay(100);  // Short delay for stability
  }
}

void alignFrontWithTwoSensors() {
  const float initialTargetDistance = 15;  // Move to  cm first
  const float finalTargetDistance = 10;    // Then fine-tune to 5 cm
  const float distanceTolerance = 0.2;     // Tolerance for reaching 6 cm
  const float alignmentTolerance = 0.1;    // Tolerance for final alignment
  const float moveSpeed = 0.2;             // Speed for moving to 6 cm
  const float fineAdjustSpeed = 0.2;       // Slow speed for final alignment
  const float reverseAdjustSpeed = 0.2;    // Speed for moving backward if too close
  bool reachedInitialTarget = false;       // Flag for transitioning to fine-tuning

  while (true) {
    float averageDistance = (distance_F1 + distance_F2) / 2.0;
    float sensorAlignmentDifference = distance_F1 - distance_F2;

    // Debugging output
    Serial.print("Front Left Distance: ");
    Serial.print(distance_F1);
    Serial.print(" cm | Front Right Distance: ");
    Serial.print(distance_F2);
    Serial.print(" cm | Average Distance: ");
    Serial.print(averageDistance);
    Serial.print(" cm | Alignment Diff: ");
    Serial.println(abs(sensorAlignmentDifference));

    // Step 1: Move toward an average distance of 6 cm
    if (!reachedInitialTarget) {
      if (abs(averageDistance - initialTargetDistance) > distanceTolerance) {
        if (averageDistance > initialTargetDistance) {
          Serial.println("Moving forward to 6 cm...");
          motorSpeedA = moveSpeed;
          motorSpeedB = moveSpeed;
          forward();
        } else {
          Serial.println("Moving backward to 6 cm...");
          motorSpeedA = moveSpeed;
          motorSpeedB = moveSpeed;
          reverse();
        }
      } else {
        Serial.println("Reached 6 cm. Switching to fine-tuning mode.");
        reachedInitialTarget = true;
        brake();
        delay(500);  // Small pause before fine-tuning
      }
    }
    // Step 2: Fine-tune each sensor to exactly 5 cm by moving forward while swiveling
    else {
      Serial.println("Fine-tuning alignment...");
      motorSpeedA = 0;
      motorSpeedB = 0;

      if (distance_F1 > finalTargetDistance || distance_F2 > finalTargetDistance) {
        if (distance_F1 > distance_F2) {
          // Left sensor is farther → Move left motor forward slightly
          Serial.println("Adjusting: Moving Left Motor Forward");
          motorSpeedA = fineAdjustSpeed;
          motorSpeedB = 0;
          forward();
        } else if (distance_F2 > distance_F1) {
          // Right sensor is farther → Move right motor forward slightly
          Serial.println("Adjusting: Moving Right Motor Forward");
          motorSpeedA = 0;
          motorSpeedB = fineAdjustSpeed;
          forward();
        } else {
          // Both sensors are close to target → Move both forward slightly
          Serial.println("Final Move: Bringing both sensors to 5 cm...");
          motorSpeedA = fineAdjustSpeed;
          motorSpeedB = fineAdjustSpeed;
          forward();
        }
      } else if (distance_F1 < finalTargetDistance || distance_F2 < finalTargetDistance) {
        if (distance_F1 < distance_F2) {
          // Left sensor is too close → Move left motor backward slightly
          Serial.println("Adjusting: Moving Left Motor Backward");
          motorSpeedA = reverseAdjustSpeed;
          motorSpeedB = 0;
          reverse();
        } else if (distance_F2 < distance_F1) {
          // Right sensor is too close → Move right motor backward slightly
          Serial.println("Adjusting: Moving Right Motor Backward");
          motorSpeedA = 0;
          motorSpeedB = reverseAdjustSpeed;
          reverse();
        }
      } else {
        // Stop when fully aligned
        Serial.println("Fully aligned at 5 cm! Stopping.");
        motorSpeedA = 0;
        motorSpeedB = 0;
        brake();
        break;
      }
    }

    // Debugging output for motor speeds
    Serial.print("Motor Speed A: ");
    Serial.print(motorSpeedA);
    Serial.print(" | Motor Speed B: ");
    Serial.println(motorSpeedB);

    // Apply motor speeds
    motorA_pwm.write(motorSpeedA);
    motorB_pwm.write(motorSpeedB);

    delay(100);  // Short delay for stability

    // Debugging output
    Serial.print("Front Left Distance: ");
    Serial.print(distance_F1);
    Serial.print(" cm | Front Right Distance: ");
    Serial.print(distance_F2);
    Serial.print(" cm | Average Distance: ");
    Serial.print(averageDistance);
    Serial.print(" cm | Alignment Diff: ");
    Serial.println(abs(sensorAlignmentDifference));
  }
}

// Align function
void alignFrontWithTwoSensorsT() {
  const float targetDistance = 5.0;  // Final target distance in cm

  while (true) {
    // Calculate the average distance
    float averageDistance = (distance_F1 + distance_F2) / 2.0;

    // Move towards the target distance
    if (averageDistance < targetDistance) {
      motorSpeedA = 0.2;
      motorSpeedB = 0.2;  // Move forward
      forward();
    } else if (averageDistance > targetDistance) {

      motorSpeedA = 0.2;
      motorSpeedB = 0.2;  // Move backward
      reverse();
    } else {
      motorSpeedA = 0;
      motorSpeedB = 0;  // Stop if aligned
    }

    // Fine-tune alignment by adjusting one motor at a time
    if (distance_F1 < targetDistance && distance_F2 > targetDistance) {
      motorSpeedA = 0.2;  // Turn left (adjust right motor)
      motorSpeedB = 0;
    } else if (distance_F1 > targetDistance && distance_F2 < targetDistance) {
      motorSpeedA = 0;
      motorSpeedB = 0.2;  // Turn right (adjust left motor)
    }

    // Break when aligned
    if (abs(distance_F1 - targetDistance) < 0.5 && abs(distance_F2 - targetDistance) < 0.5 && abs(distance_F1 - distance_F2) < 0.3) {
      motorSpeedA = 0;
      motorSpeedB = 0;  // Stop
      break;
    }
  }
}

void maintainDistancefromRightWall() {
  const float targetDistance = 5.0;     // Desired distance from the wall in
  const float distanceTolerance = 0.2;  // Tolerance for maintaining distance
  const float adjustment = 0.05;        // Adjustment increment for motors
  const float baseSpeed = 0.3;          // Base motor speed

  // Reset pulse counts and distances
  pulseCountDisA = 0;
  pulseCountDisB = 0;
  distanceA = 0;
  distanceB = 0;

  //startAvgDistanceThread();

  equalizeMotor();  // Balance the motors before starting control
  TurnCheck = false;

  while (true) {
    Serial.print("Front Distance: ");
    Serial.print(distance_R1);
    Serial.print(" | Rear Distance: ");
    Serial.println(distance_R2);

    Debug("Sensor R1 Distance: ", false);
    DebugLn(String(distance_R1), false);
    Debug("Sensor R2 Distance: ", false);
    DebugLn(String(distance_R2), false);


    // Default motor speeds
    motorSpeedB = baseSpeed;
    motorSpeedA = baseSpeed;

    // --- Maintain Distance from Right Wall ---
    if (distance_R1 > targetDistance + distanceTolerance && distance_R2 > targetDistance + distanceTolerance) {
      motorSpeedA = baseSpeed + adjustment;
      motorSpeedB = baseSpeed;
      Serial.println("Moving Closer to Wall");
    } else if (distance_R1 < targetDistance - distanceTolerance && distance_R2 < targetDistance - distanceTolerance) {
      motorSpeedA = baseSpeed;
      motorSpeedB = baseSpeed + adjustment;
      Serial.println("Moving Away from Wall");
    } else if (distance_R1 > targetDistance + distanceTolerance && distance_R2 < targetDistance - distanceTolerance) {
      motorSpeedA = baseSpeed + adjustment;
      motorSpeedB = baseSpeed;
      Serial.println("Rotating Clockwise to Align");
    } else if (distance_R1 < targetDistance - distanceTolerance && distance_R2 > targetDistance + distanceTolerance) {
      motorSpeedA = baseSpeed;
      motorSpeedB = baseSpeed + adjustment;
      Serial.println("Rotating Counterclockwise to Align");
    } else {
      motorSpeedA = baseSpeed;
      motorSpeedB = baseSpeed;
      Serial.println("Maintaining Distance from Wall");
    }

    /*       // --- Track Position Based on Distance Traveled ---
    DistanceA();
    DistanceB();
  float avgDistance = (distanceA + distanceB) / 2.0;

    if (avgDistance >= gridSize) {
      robotX += dx(robotDir);
      robotY += dy(robotDir);

      Serial.println("Updated Position:");
      Serial.print("X: ");
      Serial.print(robotX);
      Serial.print(" Y: ");
      Serial.println(robotY);

      // Reset distances
      pulseCountDisA = 0;
      pulseCountDisB = 0;
      distanceA = 0;
      distanceB = 0;
      //checkSensorsAndUpdateMaze();  // Optionally update the maze mapping
    }*/

    //ThisThread::sleep_for(80ms);
    ThisThread::sleep_for(15ms);  // Non-blocking sleep for
    // --- Obstacle Detection and Stop Condition ---
    if (wallAhead()) {
      brake();
      //stopAvgDistanceThread();
      Serial.println("Obstacle detected! Stopping.");
      break;
    }

    Debug("Grids Moved: ", false);
    DebugLn(String(totalGridsMoved), false);

    Debug("Total Distance Moved: ", false);
    DebugLn(String(totalAvgDistance), false);

    /*// Debugging output for motor speeds
    Serial.print("Motor Speed A: ");
    Serial.print(motorSpeedA);
    Serial.print(" | Motor Speed B: ");
    Serial.println(motorSpeedB);*/

    // Write motor speeds to motors
    motorA_pwm.write(motorSpeedA);
    motorB_pwm.write(motorSpeedB);
    DebugLn("End of loop", false);

    //ThisThread::sleep_for(20ms);  // Non-blocking sleep for 20ms
  }
}

void finishGridSpace() {
  const float targetDistance = 5.0;     // 5 cm for one grid space
  const float distanceTolerance = 0.2;  // Tolerance for completion (in cm)
  const float baseSpeed = 0.3;          // Base motor speed

  float remainingDistance = targetDistance - avgDistance;  // Remaining distance to cover

  // If the robot is already within tolerance of the target distance
  if (remainingDistance <= distanceTolerance) {
    DebugLn("Already within target distance, no need to move.", false);
  } else {

    // Move the robot forward until the remaining distance is covered
    while (remainingDistance > distanceTolerance) {
      DistanceA();  // Update distance measurements
      DistanceB();

      // Move the robot forward
      motorSpeedA = baseSpeed;
      motorSpeedB = baseSpeed;
      motorA_pwm.write(motorSpeedA);
      motorB_pwm.write(motorSpeedB);

      // Update the total average distance
      totalAvgDistance += avgDistance;

      // Update remaining distance
      remainingDistance = targetDistance - avgDistance;

      // Debugging information
      Debug("Total Average Distance: ", false);
      DebugLn(String(totalAvgDistance), false);
      Debug("Remaining Distance: ", false);
      DebugLn(String(remainingDistance), false);

      // Sleep to avoid blocking other operations
      ThisThread::sleep_for(20ms);
    }
  }
  // Stop the robot after reaching the target distance
  brake();

  DebugLn("Target distance reached, stopping.", false);
}


void alignFront() {

  Serial.print("Sensor F1 Distance: ");
  Serial.print(distance_F1);
  Serial.print(" cm | ");
  Serial.print("Sensor F2 Distance: ");
  Serial.print(distance_F2);
  Serial.println(" cm");

  Debug("Sensor F1 Distance: ", false);
  DebugLn(String(distance_F1), false);
  Debug("Sensor F2 Distance: ", false);
  DebugLn(String(distance_F2), false);


  if (distance_F1 > distance_F2) {
    volatile float TurnAngle = (atan2(distance_F1 - distance_F2, 9) * (180.0 / PI));
    TurnRightAngle(TurnAngle);
    Debug("Angle: ", false);
    DebugLn(String(TurnAngle), false);
  } else if (distance_F1 < distance_F2) {
    volatile float TurnAngle = (atan2(distance_F2 - distance_F1, 9) * (180.0 / PI));
    TurnLeftAngle(TurnAngle);
    Debug("Angle: ", false);
    DebugLn(String(TurnAngle), false);
  } else {  // If both distances are equal
    Serial.println("Already Aligned, No Turn Needed");
  }
}

void TurnLeftAngle(float TurnAngle) {
  Serial.println("Start Left Turn");

  float turningDistance = (abs(TurnAngle) / 360.0) * turningCircle * 0.95;  // Calculate required turn distance
  Serial.println(turningDistance);
  DebugLn(String(turningDistance), false);

  // Reset encoders
  pulseCountDisA = 0;
  pulseCountDisB = 0;

  motorSpeedA = 0.20;  // Motor A speed
  motorSpeedB = 0.20;  // Motor B speed

  left();  // Turn left
  equalizeMotor();

  DistanceA();  // Reset distance for Motor A
  DistanceB();  // Reset distance for Motor B

  // Move until the robot has turned the required angle
  while (distanceA < turningDistance && distanceB < turningDistance) {
    DistanceA();  // Update the distance for Motor A
    DistanceB();  // Update the distance for Motor B

    Serial.print("Motor A distance: ");
    Serial.print(distanceA * 100);
    Serial.println(" cm");
    Serial.print("Motor B distance: ");
    Serial.print(distanceB * 100);
    Serial.println(" cm");

    delay(100);  // Short delay for stability
  }

  Serial.print("Sensor F1 Distance: ");
  Serial.print(distance_F1);
  Serial.print(" cm | ");
  Serial.print("Sensor F1 Distance: ");
  Serial.print(distance_F1);
  Serial.println(" cm");

  Debug("Sensor F1 Distance: ", false);
  DebugLn(String(distance_F1), false);
  Debug("Sensor F2 Distance: ", false);
  DebugLn(String(distance_F2), false);

  // Stop the motors after reaching the turning target
  brake();
  Serial.println("Left Turn Completed");
}

void TurnRightAngle(float TurnAngle) {
  Serial.println("Start Left Turn");


  float turningDistance = (abs(TurnAngle) / 360.0) * turningCircle * 0.85;  // Calculate required turn distance
  Serial.println(turningDistance);
  DebugLn(String(turningDistance), false);
  // Reset encoders
  pulseCountDisA = 0;
  pulseCountDisB = 0;

  motorSpeedA = 0.2;  // Motor A speed
  motorSpeedB = 0.2;  // Motor B speed

  right();  // Turn left
  equalizeMotor();

  // Reset pulse counts
  pulseCountA = 0;
  pulseCountB = 0;

  DistanceA();  // Reset distance for Motor A
  DistanceB();  // Reset distance for Motor B

  // Move until the robot has turned the required angle
  while (distanceA < turningDistance && distanceB < turningDistance) {
    DistanceA();  // Update the distance for Motor A
    DistanceB();  // Update the distance for Motor B

    Serial.print("Motor A distance: ");
    Serial.print(distanceA * 100);
    Serial.println(" cm");
    Serial.print("Motor B distance: ");
    Serial.print(distanceB * 100);
    Serial.println(" cm");

    delay(100);  // Short delay for stability
  }

  Serial.print("Sensor F1 Distance: ");
  Serial.print(distance_F1);
  Serial.print(" cm | ");
  Serial.print("Sensor F1 Distance: ");
  Serial.print(distance_F1);
  Serial.println(" cm");

  Debug("Sensor F1 Distance: ", false);
  DebugLn(String(distance_F1), false);
  Debug("Sensor F2 Distance: ", false);
  DebugLn(String(distance_F2), false);

  // Stop the motors after reaching the turning target
  brake();
  Serial.println("Left Turn Completed");
}


/*else {
      // --- Stage 2: Align the Robot ---
      float alignmentDifference = distance_R2 - distance_R1;

      if (abs(alignmentDifference) > alignmentTolerance) {
        if (alignmentDifference > alignmentTolerance) {
          // Rear is farther than the front -> Turn left
          motorSpeedA = baseSpeed;
          motorSpeedB = min(baseSpeed + adjustment, 1.0);  // Speed up left motor
          Serial.println("Adjusting: Turning Left (Not Parallel)");
        } else if (alignmentDifference < -alignmentTolerance) {
          // Front is farther than the rear -> Turn right
          motorSpeedA = min(baseSpeed + adjustment, 1.0);  // Speed up right motor
          motorSpeedB = baseSpeed;
          Serial.println("Adjusting: Turning Right (Not Parallel)");
        }
      } else {
        // Robot is aligned and within the target range
        motorSpeedA = baseSpeed;
        motorSpeedB = baseSpeed;
        Serial.println("Maintaining Position");
      }
    }*/

void motorA_up() {
  motorSpeedA = min(motorSpeedA + 0.1, 1.0);
  motorA_pwm.write(motorSpeedA);
  Serial.print("Motor A speed increased to ");
  Serial.println(motorSpeedA);
}

void motorB_up() {
  motorSpeedB = min(motorSpeedB + 0.1, 1.0);
  motorB_pwm.write(motorSpeedB);
  Serial.print("Motor B speed increased to ");
  Serial.println(motorSpeedB);
}

void motorA_down() {
  motorSpeedA = max(motorSpeedA - 0.1, 0.0);
  motorA_pwm.write(motorSpeedA);
  Serial.print("Motor A speed decreased to ");
  Serial.println(motorSpeedA);
}

void motorB_down() {
  motorSpeedB = max(motorSpeedB - 0.1, 0.0);
  motorB_pwm.write(motorSpeedB);
  Serial.print("Motor B speed decreased to ");
  Serial.println(motorSpeedB);
}

void forward() {
  motorA_dir = 1;
  motorB_dir = 0;
  Serial.println("Motors set to forward.");
}

void reverse() {
  motorA_dir = 0;
  motorB_dir = 1;
  Serial.println("Motors set to reverse.");
}

void left() {
  motorA_dir = 1;
  motorB_dir = 1;
  Serial.println("Motors set to left turn");
}

void right() {
  motorA_dir = 0;
  motorB_dir = 0;
  Serial.println("Motors set to right turn");
}

void brake() {
  motorA_pwm.write(0);
  motorB_pwm.write(0);
  Serial.println("Motors stopped.");
}

void DistanceA() {
  distanceA = pulseCountDisA * distancePerPulseA;  // Distance for Motor A
  distanceA2 = pulseCountDisA * distancePerPulseA;  // finsihgridspace
}

void DistanceB() {
  distanceB = pulseCountDisB * distancePerPulseB;  // Distance for Motor B
    distanceB2 = pulseCountDisB * distancePerPulseB;  // finsihgridspace

}

void reset() {
  brake();
  distanceA = 0.0;
  distanceB = 0.0;
  pulseCountDisA = 0;
  pulseCountDisB = 0;
}

void equalizeMotor() {
  Equalized = 0;  // Reset the equalization flag

  while (Equalized == 0) {
    // Calculate RPM based on accumulated pulses
    motorSpeedReadA = (pulseCountA / pulsesPerRevolutionA);
    motorSpeedReadB = (pulseCountB / pulsesPerRevolutionB);

    // Reset pulse counts
    pulseCountA = 0;
    pulseCountB = 0;

    float diff = motorSpeedReadB - motorSpeedReadA;

    if (diff > 3) {
      motorSpeedB = max(motorSpeedB - 0.01, 0.0);  // Decrease Motor B speed
      /*Serial.print(motorSpeedReadB);
      Serial.print(" > ");
      Serial.print(motorSpeedReadA);
      Serial.print(" by ");
      Serial.print(diff);
      Serial.print(" Decrementing B to ");
      Serial.println(motorSpeedB);*/
    }
    if (diff < -3) {
      motorSpeedA = max(motorSpeedA - 0.01, 0.0);  // Decrease Motor A speed
      /*Serial.print(motorSpeedReadB);
      Serial.print(" < ");
      Serial.print(motorSpeedReadA);
      Serial.print(" by ");
      Serial.print(diff);
      Serial.print(" Decrementing A to ");
      Serial.println(motorSpeedA);*/
    }

    motorA_pwm.write(motorSpeedA);
    motorB_pwm.write(motorSpeedB);

    // Debugging output
    /*Serial.print("Motor A RPM: ");
    Serial.println(motorSpeedReadA);
    Serial.print("Motor B RPM: ");
    Serial.println(motorSpeedReadB);
    Serial.print("Difference in RPM: ");
    Serial.println(diff);
    Serial.print("PWM A: ");
    Serial.println(motorSpeedA);
    Serial.print("PWM B: ");
    Serial.println(motorSpeedB);
    Serial.print("RPM A: ");
    Serial.println(motorSpeedReadA);
    Serial.print("RPM B: ");
    Serial.println(motorSpeedReadB);*/

    // Allow encoders to accumulate pulses
    delay(500);  // Adjust based on encoder response time

    // Check if RPMs are within ±10
    if (abs(motorSpeedReadA - motorSpeedReadB) <= 3) {
      Equalized = 1;
      //Serial.println("Motors successfully equalized.");
    }
  }
}

void turnninetyleft() {
  Serial.println(" Start turn");
  TurnCheck = true;

  left();  // Set the motors to move forward

  // Reset pulse counts to track how many pulses have been received
  pulseCountDisA = 0;
  pulseCountDisB = 0;

  motorSpeedA = 0.25;  // Motor A speed
  motorSpeedB = 0.25;  // Motor B speed

  equalizeMotor();

  DistanceA();  // Update the distance for Motor A before loop set to 0
  DistanceB();  // Update the distance for Motor B before loop set to 0

  // Calculate the number of pulses needed to move 10 cm
  //float pulsesToMove = 10.0 / distancePerPulseA;  // Distance in cm / distance per pulse (in meters)

  // Move until the robot has traveled 10 cm
  while (distanceA < 0.07 && distanceB < 0.07) {  //   0.0365
    DistanceA();                                  // Update the distance for Motor A
    DistanceB();                                  // Update the distance for Motor B

    Serial.print("Motor A distance: ");
    Serial.print(distanceA * 100);
    Serial.println(" cm");
    Serial.print("Motor B distance: ");
    Serial.print(distanceB * 100);
    Serial.println(" cm");

    // Allow time for the loop to run at a reasonable speed
    delay(100);  // 100ms delay between distance checks
  }

  // Once the robot has moved 10 cm, stop the motors
  brake();

  // Update robot's direction after a 90-degree left turn (counterclockwise)
  robotDir = (robotDir - 1 + 4) % 4;  // Update direction by -1 (mod 4)
  TurnCheck = false;
  Serial.println("Turned Left 90");
}

void turnninetyright() {
  Serial.println(" Start turn");
  TurnCheck = true;


  right();  // Set the motors to move forward

  // Reset pulse counts to track how many pulses have been received
  pulseCountDisA = 0;
  pulseCountDisB = 0;

  motorSpeedA = 0.25;  // Motor A speed
  motorSpeedB = 0.25;  // Motor B speed

  equalizeMotor();

  DistanceA();  // Update the distance for Motor A before loop set to 0
  DistanceB();  // Update the distance for Motor B before loop set to 0

  // Calculate the number of pulses needed to move 10 cm
  //float pulsesToMove = 10.0 / distancePerPulseA;  // Distance in cm / distance per pulse (in meters)

  // Move until the robot has traveled 10 cm
  while (distanceA < 0.07 && distanceB < 0.07) {  //   0.0365
    DistanceA();                                  // Update the distance for Motor A
    DistanceB();                                  // Update the distance for Motor B

    Serial.print("Motor A distance: ");
    Serial.print(distanceA * 100);
    Serial.println(" cm");
    Serial.print("Motor B distance: ");
    Serial.print(distanceB * 100);
    Serial.println(" cm");

    // Allow time for the loop to run at a reasonable speed
    delay(100);  // 100ms delay between distance checks
  }

  // Once the robot has moved 10 cm, stop the motors
  brake();

  robotDir = (robotDir + 1) % 4;  // Update direction by +1 (mod 4)
  TurnCheck = false;
  Serial.println("Turned Right 90");
  reset();
  delay(10);
}

void turnfourtyfiveleft() {
  Serial.println(" Start turn");
  left();  // Set the motors to move forward

  // Reset pulse counts to track how many pulses have been received
  pulseCountDisA = 0;
  pulseCountDisB = 0;

  motorSpeedA = 0.3;  // Motor A speed
  motorSpeedB = 0.3;  // Motor B speed

  equalizeMotor();

  DistanceA();  // Update the distance for Motor A before loop set to 0
  DistanceB();  // Update the distance for Motor B before loop set to 0

  // Calculate the number of pulses needed to move 10 cm
  //float pulsesToMove = 10.0 / distancePerPulseA;  // Distance in cm / distance per pulse (in meters)

  // Move until the robot has traveled 10 cm
  while (distanceA < 0.035 && distanceB < 0.035) {  //   0.0365
    DistanceA();                                    // Update the distance for Motor A
    DistanceB();                                    // Update the distance for Motor B

    Serial.print("Motor A distance: ");
    Serial.print(distanceA * 100);
    Serial.println(" cm");
    Serial.print("Motor B distance: ");
    Serial.print(distanceB * 100);
    Serial.println(" cm");

    // Allow time for the loop to run at a reasonable speed
    delay(100);  // 100ms delay between distance checks
  }

  // Once the robot has moved 10 cm, stop the motors
  brake();

  //robotDir = (robotDir - 1 + 4) % 4;  // Update direction by -1 (mod 4)

  Serial.println("Turned Left 45");
}

void turnfourtyfiveright() {
  Serial.println(" Start turn");
  right();  // Set the motors to move forward

  // Reset pulse counts to track how many pulses have been received
  pulseCountDisA = 0;
  pulseCountDisB = 0;

  motorSpeedA = 0.3;  // Motor A speed
  motorSpeedB = 0.3;  // Motor B speed

  equalizeMotor();

  DistanceA();  // Update the distance for Motor A before loop set to 0
  DistanceB();  // Update the distance for Motor B before loop set to 0

  // Calculate the number of pulses needed to move 10 cm
  //float pulsesToMove = 10.0 / distancePerPulseA;  // Distance in cm / distance per pulse (in meters)

  // Move until the robot has traveled 10 cm
  while (distanceA < 0.035 && distanceB < 0.035) {  //   0.0365
    DistanceA();                                    // Update the distance for Motor A
    DistanceB();                                    // Update the distance for Motor B

    Serial.print("Motor A distance: ");
    Serial.print(distanceA * 100);
    Serial.println(" cm");
    Serial.print("Motor B distance: ");
    Serial.print(distanceB * 100);
    Serial.println(" cm");

    // Allow time for the loop to run at a reasonable speed
    delay(100);  // 100ms delay between distance checks
  }

  // Once the robot has moved 10 cm, stop the motors
  brake();

  //robotDir = (robotDir + 1) % 4;  // Update direction by +1 (mod 4)

  Serial.println("Turned Right 45");
}

void turn180() {
  turnninetyleft();
  delay(250);
  turnninetyleft();
  delay(250);

  brake();
}
/*
void moveforward1gird() {

  forward();  // Set the motors to move forward

  motorSpeedA = 0.5;  // Motor A speed
  motorSpeedB = 0.5;  // Motor B speed

  equalizeMotor();  // Equalize motor speeds for both motors

  // Reset pulse counts to track how many pulses have been received
  pulseCountDisA = 0;
  pulseCountDisB = 0;

  // Track the total distance traveled
  distanceA = 0;
  distanceB = 0;

  float gridSize = 0.05;

  // Move until the robot has traveled one grid
  while (distanceA < gridSize && distanceB < gridSize) {
    DistanceA();  // Update the distance for Motor A
    DistanceB();  // Update the distance for Motor B

    Serial.print("Motor A distance: ");
    Serial.print(distanceA * 100);
    Serial.println(" cm");
    Serial.print("Motor B distance: ");
    Serial.print(distanceB * 100);
    Serial.println(" cm");

    delay(100);
  }

  brake();
  Serial.println("stopped");

   // Update the robot's position on the map after moving
  robotX += dx(robotDir);
  robotY += dy(robotDir);

  // Mark the current position and surrounding areas on the maze map
  updateMazeMap();
  displayMazeMap();

  Serial.println("Moved 5 cm and updated the map.");

  // Now, check the sensors and update the maze based on the sensor readings
  checkSensorsAndUpdateMaze();

  updateMazeMap();
  displayMazeMap();
}*/

void moveten() {
  forward();  // Set the motors to move forward

  // Reset pulse counts to track how many pulses have been received
  pulseCountDisA = 0;
  pulseCountDisB = 0;

  motorSpeedA = 0.3;  // Motor A speed
  motorSpeedB = 0.3;  // Motor B speed

  equalizeMotor();

  DistanceA();  // Update the distance for Motor A before loop set to 0
  DistanceB();  // Update the distance for Motor B before loop set to 0

  // Calculate the number of pulses needed to move 10 cm
  //float pulsesToMove = 10.0 / distancePerPulseA;  // Distance in cm / distance per pulse (in meters)

  // Move until the robot has traveled 10 cm
  while (distanceA < 0.125 && distanceB < 0.125) {  // 0.1 m = 10 cm
    DistanceA();                                    // Update the distance for Motor A
    DistanceB();                                    // Update the distance for Motor B

    // Optional: Print out the current distance (for debugging purposes)
    Serial.print("Motor A distance: ");
    Serial.print(distanceA * 100);
    Serial.println(" cm");
    Serial.print("Motor B distance: ");
    Serial.print(distanceB * 100);
    Serial.println(" cm");

    // Allow time for the loop to run at a reasonable speed
    delay(100);  // 100ms delay between distance checks
  }

  // Once the robot has moved 10 cm, stop the motors
  brake();
  Serial.println("Moved 10 cm and stopped.");
}

void moveforward() {
  // Assuming each move is 5 cm, which is 1 grid cell.
  //float gridSize = 0.05;  // Grid size is 5 cm (adjust if necessary)
  TurnCheck = false;

  // Reset pulse counts and distance for both motors
  pulseCountDisA = 0;
  pulseCountDisB = 0;

  // Start moving the robot
  forward();  // Move the robot forward

  motorSpeedA = 0.3;  // Motor A speed
  motorSpeedB = 0.3;  // Motor B speed
  equalizeMotor();    // Ensure both motors are equalized

  DistanceA();
  DistanceB();

  // Move until the robot has traveled 1 grid cell (5 cm)
  while (distanceA < gridSize && distanceB < gridSize) {
    DistanceA();  // Update the distance for Motor A
    DistanceB();  // Update the distance for Motor B

    // Debugging information (optional)
    Serial.print("Motor A distance: ");
    Serial.print(distanceA * 100);  // Convert to cm
    Serial.println(" cm");
    Serial.print("Motor B distance: ");
    Serial.print(distanceB * 100);  // Convert to cm
    Serial.println(" cm");
  }

  // Stop the motors after moving the grid size
  brake();
  Serial.println("Stopped after moving 5 cm (1 grid cell)");
  /*
  //Update the robot's position and the maze
  robotX += dx(robotDir);  // Update X position based on direction
  robotY += dy(robotDir);  // Update Y position based on direction
*/
  // Update the maze based on sensor data
  // updateMazeMap();
  // displayMazeMap();  // Optional: display the updated maze

  // Check sensors and update the maze based on detected walls or obstacles
  checkSensorsAndUpdateMaze();

  // Optionally, you could add a small delay here to avoid too frequent updates
  delay(100);
}

void moveForwardt(int numCells) {
  float gridSize = 0.05;                       // 5 cm per grid cell
  float targetDistance = numCells * gridSize;  // Total distance to move

  // Reset pulse counts and distance for both motors
  pulseCountDisA = 0;
  pulseCountDisB = 0;

  // Start moving forward
  forward();
  motorSpeedA = 0.3;
  motorSpeedB = 0.3;
  equalizeMotor();

  DistanceA();
  DistanceB();

  while ((distanceA < targetDistance) && (distanceB < targetDistance)) {
    DistanceA();
    DistanceB();

    // If the robot moves at least 1 grid space, update position
    /*if (distanceA >= gridSize && distanceB >= gridSize) {
      robotX += dx(robotDir); //POSSIBLE
      robotY += dy(robotDir);

      Serial.println("Updated Position:");
      Serial.print("X: ");
      Serial.print(robotX);
      Serial.print(" Y: ");
      Serial.println(robotY);

      // Reset distances for the next grid space
      pulseCountDisA = 0;
      pulseCountDisB = 0;
      distanceA = 0;
      distanceB = 0;

      // Update the maze with sensor data
      checkSensorsAndUpdateMaze();
    }*/

    // Stop early if an obstacle is detected
    if (wallAhead()) {
      brake();
      Serial.println("Obstacle detected! Stopping.");
      return;
    }
  }

  // Stop the motors after moving the required grid spaces
  brake();
  Serial.println("Reached target distance. Stopping.");
}

void moveForward(int numCells) {
  float gridSize = 0.05;                       // 5 cm per grid cell (in meters)
  float targetDistance = numCells * gridSize;  // Total distance to move (in meters)

  int gridsMoved = 0;
  float totalDistanceTravelled = 0.0;

  // Reset pulse counts and distance for both motors
  pulseCountDisA = 0;
  pulseCountDisB = 0;
  distanceA = 0;
  distanceB = 0;

  // Start moving forward
  forward();
  motorSpeedA = 0.3;
  motorSpeedB = 0.3;
  equalizeMotor();

  DistanceA();
  DistanceB();

  while ((distanceA < targetDistance) && (distanceB < targetDistance)) {
    DistanceA();
    DistanceB();

    // If the robot moves at least one grid cell (5 cm), update position
    /*if (distanceA >= gridSize && distanceB >= gridSize) {
      // Update grid count and total distance travelled
      gridsMoved++;
      totalDistanceTravelled += gridSize;

      // Update the robot's grid position
      robotX += dx(robotDir); //POSSIBLE
      robotY += dy(robotDir);

      Serial.println("Updated Position:");
      Serial.print("X: ");
      Serial.print(robotX);
      Serial.print(" Y: ");
      Serial.println(robotY);

      // Print current progress
      Serial.print("Grids moved: ");
      Serial.println(gridsMoved);
      Serial.print("Total distance travelled (cm): ");
      Serial.println(totalDistanceTravelled * 100);  // converting meters to cm

      // Reset distances for the next grid space
      pulseCountDisA = 0;
      pulseCountDisB = 0;
      distanceA = 0;
      distanceB = 0;

      // Update the maze with sensor data
      checkSensorsAndUpdateMaze();
    }*/

    // Stop early if an obstacle is detected
    if (wallAhead()) {
      brake();
      Serial.println("Obstacle detected! Stopping.");
      return;
    }
  }

  // Stop the motors after moving the required grid spaces
  brake();
  Serial.println("Reached target distance. Stopping.");

  // Final print-out of total progress
  Serial.print("Final grids moved: ");
  Serial.println(gridsMoved);
  Serial.print("Final total distance travelled (cm): ");
  Serial.println(totalDistanceTravelled * 100);
}

void moveForwardContinuous() {
  float gridSize = 0.05;  // 5 cm per grid cell

  // Reset pulse counts and distance for both motors
  pulseCountDisA = 0;
  pulseCountDisB = 0;

  //startWallControlThread();


  // Start moving the robot forward
  forward();
  motorSpeedA = 0.3;
  motorSpeedB = 0.3;
  equalizeMotor();

  DistanceA();
  DistanceB();

  while (true) {  // Continuous movement
    DistanceA();
    DistanceB();

    /*float avgDistance = (distanceA + distanceB) / 2.0;

    // Check if the robot has moved 1 grid space
    //if (distanceA >= gridSize && distanceB >= gridSize) {
    if (avgDistance >= gridSize) {
      // Update position
      robotX += dx(robotDir); //POSSIBLE
      robotY += dy(robotDir);

      Serial.println("Updated Position:");
      Serial.print("X: ");
      Serial.print(robotX);
      Serial.print(" Y: ");
      Serial.println(robotY);

      // Reset distances
      pulseCountDisA = 0;
      pulseCountDisB = 0;
      distanceA = 0;
      distanceB = 0;

      // Optionally, check sensors and update maze
      checkSensorsAndUpdateMaze();
    }*/

    // Safety stop condition (e.g., obstacle detected)
    if (wallAhead()) {
      brake();
      //stopWallControlThread();

      Serial.println("Obstacle detected! Stopping.");
      return;
    }
  }
}

void moveback() {
  reverse();  // Set the motors to move

  pulseCountDisA = 0;
  pulseCountDisB = 0;

  motorSpeedA = 0.3;  // Motor A speed
  motorSpeedB = 0.3;  // Motor B speed

  equalizeMotor();

  DistanceA();  // Update the distance for Motor A before loop set to 0
  DistanceB();  // Update the distance for Motor B before loop set to 0


  // Move until the robot has traveled 1 cm
  while (distanceA < 0.01 && distanceB < 0.01) {  // 0.01 m = 1 cm
    DistanceA();                                  // Update the distance for Motor A
    DistanceB();                                  // Update the distance for Motor B

    // Optional: Print out the current distance (for debugging purposes)
    Serial.print("Motor A distance: ");
    Serial.print(distanceA * 100);
    Serial.println(" cm");
    Serial.print("Motor B distance: ");
    Serial.print(distanceB * 100);
    Serial.println(" cm");

    // Allow time for the loop to run at a reasonable speed
    delay(100);  // 100ms delay between distance checks
  }
}

void checknmovewallahead() {

  float minDistanceThreshold = 10.0;  // in cm


  while (true) {
    checksensors();  // Check the sensor distances

    // Read distance from Sensor 1
    float distance_F1 = readDistanceCM();
    Serial.print("Sensor 1 Distance: ");
    Serial.print(distance_F1);
    Serial.println(" cm");

    if (distance_F1 < minDistanceThreshold) {  // Check if the distance from Sensor 1 falls below the threshold

      brake();
      Serial.println("Wall in front. Stopping robot.");

      turn180();

    } else {  // If the distance is fine, move the robot

      moveforward();
    }

    //delay(100);
  }
}

void checknmovewallleft() {

  float minDistanceThreshold = 10.0;  // in cm

  while (true) {
    checksensors();  // Check sensor

    float distance_F1 = readDistanceCM();
    Serial.print("Sensor 1 Distance: ");
    Serial.print(distance_F1);
    Serial.println(" cm");

    if (distance_F1 < minDistanceThreshold) {
      brake();
      Serial.println("Wall in front, stopping robot");

      //moveback();

      checksensors();

      float distance_R1 = readDistanceCM();  //left sensor
      Serial.print("Left Sensor Distance: ");
      Serial.print(distance_R1);
      Serial.println(" cm");

      float distance_R2 = readDistanceCM();  //right sensor
      Serial.print("Right Sensor Distance: ");
      Serial.print(distance_R2);
      Serial.println(" cm");

      if (distance_R1 > minDistanceThreshold) {
        Serial.println("Left sensor is clear, turning 45 degrees left twice.");
        turnfourtyfiveleft();
        delay(500);
        turnfourtyfiveleft();
      }
    } else {
      moveforward();
    }

    //delay(100);
  }
}

void checknmove1() {
  float minDistanceThresholdFront = 10.0;  // in cm
  float minDistanceThresholdLeft = 15.0;   // in cm

  checksensors();  // Check sensor

  while (true) {
    checksensors();  // Check sensor

    float distance_R1 = readDistanceCM();  // Left sensor
    Serial.print("Left Sensor Distance: ");
    Serial.print(distance_R1);
    Serial.println(" cm");

    if (distance_R1 > minDistanceThresholdLeft) {
      // If the left sensor detects a gap, turn 45 degrees left twice
      brake();

      Serial.println("Gap detected on the left, turning 45 degrees left twice.");

      turnfourtyfiveleft();

      delay(200);

      turnfourtyfiveleft();

      moveforward();

      delay(100);


    } else {

      float distance_F1 = readDistanceCM();  // Check the front sensor
      Serial.print("Sensor 1 Distance: ");
      Serial.print(distance_F1);
      Serial.println(" cm");

      if (distance_F1 < minDistanceThresholdFront) {  // If a wall is detected in front, stop and turn 180 degrees

        brake();

        Serial.println("Wall detected ahead, stopping and turning 180 degrees.");

        turn180();

        // Resume looking for a gap in the left wall
        moveforward();
      } else {
        // Continue moving forward if there's no wall ahead
        moveforward();
      }
    }

    delay(100);  // Small delay to avoid excessive sensor polling
  }
}

void checknmove() {

  float minDistanceThresholdFront = 15.0;  // in cm
  float minDistanceThresholdLeft = 20.0;   // in cm
  float minDistanceThresholdRight = 20.0;  // in cm

  while (true) {
    checksensors();

    //setMultiplexerBus(MUX_BUS_2);
    //float distance_R1 = readDistanceCM();  // Left sensor
    //setMultiplexerBus(MUX_BUS_0);
    //float distance_F1 = readDistanceCM();  // Front sensor

    Serial.print("Left Sensor Distance: ");
    Serial.print(distance_R1);
    Serial.println(" cm");

    Serial.print("Front Sensor Distance: ");
    Serial.print(distance_F1);
    Serial.println(" cm");

    if (distance_R1 > minDistanceThresholdLeft) {

      // moveforward1gird();
      moveten();
      //  moveforward1gird();

      brake();

      checksensors();

      Serial.println("Gap detected on the left, turning 45 degrees left twice.");

      turnfourtyfiveleft();

      delay(200);

      turnfourtyfiveleft();

      moveforward();

      delay(100);

    } else {
      if (distance_F1 < minDistanceThresholdFront) {
        brake();
        checksensors();

        Serial.println("Wall detected ahead.");

        // Check right sensor if the front sensor detects a wall
        if (distance_R2 > minDistanceThresholdRight) {
          Serial.println("Right side clear, turning 90 degrees to the right.");

          turnfourtyfiveright();

          delay(200);

          turnfourtyfiveright();

          moveforward();
        } else {

          if (distance_F1 < minDistanceThresholdFront) {

            brake();

            checksensors();

            Serial.println("Wall detected ahead, stopping and turning 180 degrees.");

            turn180();

            checksensors();

            moveforward();
          } else {


            moveforward();
          }
        }

        delay(100);  // Small delay to avoid excessive sensor polling
      }
    }
  }
}


void checkSensorsAndUpdateMazeT() {
  // Sensor threshold for detecting walls
  float Threshold = 50.0;     // Adjust as per environment (in cm)
  int maxDistanceCells = 10;  // Maximum grid cells to mark free

  // Directions for sensors
  int frontDx = dx(robotDir);   // Directional change for front sensor (X)
  int frontDy = dy(robotDir);   // Directional change for front sensor (Y)
  int leftDx = -dy(robotDir);   // Directional change for left sensor (X)
  int leftDy = dx(robotDir);    // Directional change for left sensor (Y)
  int rightDx = dy(robotDir);   // Directional change for right sensor (X)
  int rightDy = -dx(robotDir);  // Directional change for right sensor (Y)

  // Process the front sensor
  if (distance_F1 < Threshold) {
    Serial.print(distance_F1);
    Serial.println("Wall detected ahead.");
    processSensorData(distance_F1, robotX, robotY, frontDx, frontDy, true);
  } else {
    Serial.println("No wall detected ahead.");
    processSensorData(distance_F1, robotX, robotY, frontDx, frontDy, false);
  }

  if (distance_F2 < Threshold) {
    Serial.print(distance_F2);
    Serial.println("Wall detected ahead.");
    processSensorData(distance_F1, robotX, robotY, frontDx, frontDy, true);
  } else {
    Serial.println("No wall detected ahead.");
    processSensorData(distance_F1, robotX, robotY, frontDx, frontDy, false);
  }

  // Process the left sensor
  if (distance_R1 < Threshold) {
    Serial.print(distance_R1);
    Serial.println("Wall detected on the left.");
    processSensorData(distance_R1, robotX, robotY, leftDx, leftDy, true);
  } else {
    Serial.println("No wall detected on the left.");
    processSensorData(distance_R1, robotX, robotY, leftDx, leftDy, false);
  }

  // Process the right sensor
  if (distance_R2 < Threshold) {
    Serial.print(distance_R2);
    Serial.println("Wall detected on the right.");
    processSensorData(distance_R2, robotX, robotY, rightDx, rightDy, true);
  } else {
    Serial.println("No wall detected on the right.");
    processSensorData(distance_R2, robotX, robotY, rightDx, rightDy, false);
  }
}

/*void checkSensorsAndUpdateMaze() {

  float minDistanceThresholdLeft = 15.0;  // in cm

  if (distance_F1 < wallThreshold) {
    Serial.println("Wall detected ahead.");
    // Mark the front grid as a wall (e.g., "1")
    markAsWall(robotX + dx(robotDir), robotY + dy(robotDir));
  } else {
    Serial.println("No wall detected ahead.");
    // Mark the front grid as unknown (e.g., "?")
    markAsUnknown(robotX + dx(robotDir), robotY + dy(robotDir));
  }

  // Check left sensor
  if (distance_R1 < wallThreshold) {
    Serial.println("Wall detected on the left.");
    // Mark the left grid as a wall (e.g., "1")
    markAsWall(robotX - 1, robotY);  // Assuming moving left changes X position
  } else {
    Serial.println("No wall detected on the left.");
    // Mark the left grid as unknown (e.g., "?")
    markAsUnknown(robotX - 1, robotY);
  }

  // Check right sensor
  if (distance_R2 < wallThreshold) {
    Serial.println("Wall detected on the right.");
    // Mark the right grid as a wall (e.g., "1")
    markAsWall(robotX + 1, robotY);  // Assuming moving right changes X position
  } else {
    Serial.println("No wall detected on the right.");
    // Mark the right grid as unknown (e.g., "?")
    markAsUnknown(robotX + 1, robotY);
  }
}

void checkSensorsAndUpdateMaze() {
    // Directions for sensors
    int frontDx = dx(robotDir);       // Directional change for front sensor (X)
    int frontDy = dy(robotDir);       // Directional change for front sensor (Y)
    int leftDx = -dy(robotDir);       // Directional change for left sensor (X)
    int leftDy = dx(robotDir);        // Directional change for left sensor (Y)
    int rightDx = dy(robotDir);       // Directional change for right sensor (X)
    int rightDy = -dx(robotDir);      // Directional change for right sensor (Y)

    // Process front sensor
    processSensorData(distance_F1, robotX, robotY, frontDx, frontDy);

    // Process left sensor
    processSensorData(distance_R1, robotX, robotY, leftDx, leftDy);

    // Process right sensor
    processSensorData(distance_R2, robotX, robotY, rightDx, rightDy);
}

void checkSensorsAndUpdateMaze() {
    // Sensor threshold for detecting walls
    float wallThreshold = 15.0;  // Adjust as per environment (in cm)
    int maxDistanceCells = 10;   // Maximum grid cells to mark free

    // Process the front sensor
    if (distance_F1 < wallThreshold) {
        Serial.println("Wall detected ahead.");
        processSensorData(robotX, robotY, robotDir, distance_F1, true);
    } else {
        Serial.println("No wall detected ahead.");
        processSensorData(robotX, robotY, robotDir, distance_F1, false);
    }

    // Process the left sensor (relative to the center)
    if (distance_R1 < wallThreshold) {
        Serial.println("Wall detected on the left.");
        processSensorData(robotX, robotY, (robotDir + 3) % 4, distance_R1, true);
    } else {
        Serial.println("No wall detected on the left.");
        processSensorData(robotX, robotY, (robotDir + 3) % 4, distance_R1, false);
    }

    // Process the right sensor (relative to the center)
    if (distance_R2 < wallThreshold) {
        Serial.println("Wall detected on the right.");
        processSensorData(robotX, robotY, (robotDir + 1) % 4, distance_R2, true);
    } else {
        Serial.println("No wall detected on the right.");
        processSensorData(robotX, robotY, (robotDir + 1) % 4, distance_R2, false);
    }

    // Optionally: Add rear sensor handling if applicable
}
*/

void loop() {
  BLEDevice central = BLE.central();

  if (central) {
    // Serial.print("Connected to: ");
    //Serial.println(central.address());

    while (central.connected()) {
      // Check Bluetooth input
      if (rxCharacteristic.written()) {
        char command = rxCharacteristic.value()[0];
        Serial.print("Received from BLE: ");
        Serial.println(command);
        processCommand(command);
      }
      // Check Serial input (USB)
      if (Serial.available() > 0) {
        char command = Serial.read();
        Serial.print("Received from Serial: ");
        Serial.println(command);
        processCommand(command);
      }
    }
    //Serial.println("Disconnected");
  }

  // Always check Serial input, even if no BLE connection
  if (Serial.available() > 0) {
    char command = Serial.read();
    Serial.print("Received from Serial: ");
    Serial.println(command);
    processCommand(command);
  }
}

// Process received command
void processCommand(char command) {
  if (command == 'w') {
    forward();
  } else if (command == 'a') {
    left();
  } else if (command == 'd') {
    right();
  } else if (command == 's') {
    reverse();
  } else if (command == 'b') {
    brake();
  } else if (command == 'g') {
    moveforward();
  } else if (command == 'n') {
    checksensorscheck();
  } else if (command == 'u') {
    motorA_up();
    motorB_up();
  } else if (command == 'h') {
    motorA_down();
    motorB_down();
  } else if (command == 'e') {
    equalizeMotor();
  } else if (command == 'r') {
    reset();
  } else if (command == 'm') {
    moveForwardContinuous();
  } else if (command == 'l') {
    turnninetyleft();
  } else if (command == 'j') {
    turnninetyright();
  } else if (command == 'p') {
    checkSensorsAndUpdateMaze();
    updateMazeMap();
    smartMapUnknowns();
    displayMazeMap();
    displayMazeMapOverBLE();
  } else if (command == 'c') {
    motorA_pwm.write(motorSpeedA);
    motorB_pwm.write(motorSpeedB);
    motorSpeedA = 0.3;
    motorSpeedB = 0;
  } else if (command == 'f') {
    finishGridSpace();
  } else if (command == 'o') {
    turn180();
  } else if (command == 'k') {
    maintainDistancefromRightWall();
  } else if (command == 'y') {
    alignFront();
  } else if (command >= '1' && command <= '9') {  // If command is a digit (1-9)
    int numCells = command - '0';                 // Convert char to integer
    Serial.print("Moving forward by ");
    Serial.print(numCells);
    Serial.println(" grid spaces.");
    moveForward(numCells);
  } else if (command == 'x') {
    // Start continuous forward movement
    Serial.println("Starting Continuous Forward with Wall Following");
    txCharacteristic.writeValue("Starting Continuous Forward with Wall Following");
    // Enable wall distance control
    //startWallControlThread();
    // Move forward continuously
    //moveForwardContinuous();
  } else if (command == 'q') {
    // Stop all movement and wall control
    Serial.println("Stopping Movement and Wall Following");
    txCharacteristic.writeValue("Stopping Movement and Wall Following");
    // Stop the distance control thread
    //stopWallControlThread();
    // Stop movement
    brake();
  } /*else if (command == 'z') {
    Serial.println("Stopping Movement and Wall Following");
    txCharacteristic.writeValue("Stopping Movement and Wall Following");
    stopCommandReceived = true;  // Set flag to stop any loops
    stopWallControlThread();
    brake();
  }*/
}


/*void loop() {
  // Check if data is available on the serial port
  if (Serial.available() > 0) {
    // Read incoming byte
    char command = Serial.read();

    // Check the command and adjust motor behavior accordingly
    if (command == 'w') {  // 'w' for forward
      forward();
    } else if (command == 'a') {  // 'a' for spin left
      left();
    } else if (command == 'd') {  // 'd' for spin right
      right();
    } else if (command == 's') {  // 's' for reverse
      reverse();
    } else if (command == 'b') {  // 'b' for stop
      brake();
    } else if (command == 'g') {  // 'go' for stop
      moveforward();
    } else if (command == 'n') {  // 'go' for stop
      checksensorscheck();
    } else if (command == 'u') {  // 'u' for +0.1
      motorA_up();
      motorB_up();
    } else if (command == 'h') {  // 'h' for -0.1
      motorA_down();
      motorB_down();
    } else if (command == 'e') {  // 'e' for equalize
      equalizeMotor();
    } else if (command == 'r') {  // reset varibles
      reset();
    } else if (command == 'm') {  // 'm' move 10cm
      moveten();
    } else if (command == 'l') {  // 'l' turn left 45
      turnninetyleft();
    } else if (command == 'j') {  // 'j' turn right 45
      turnninetyright();
    } else if (command == 'p') {
      checkSensorsAndUpdateMaze();
      updateMazeMap();
      displayMazeMap();
    } else if (command == 'c') {  // '90' turn left 90
      turnfourtyfiveleft();
    } else if (command == 't') {
      checknmove();
    } else if (command == 'r') {
      moveback();
    } else if (command == 'o') {
      turn180();
    } else if (command == 'k') {
      maintainDistancefromRightWall();
    } else if (command == 'y') {
      alignFrontWithTwoSensors();
    }
  }

  //checksensors();

  // Calculate and print speed every second
  if (speedTimer.read() >= 1.0) {  // 1 second elapsed
    speedTimer.reset();

    // Calculate motor A speed in RPM
    motorSpeedReadA = (pulseCountA / pulsesPerRevolutionA) * 60.0;  // Convert to RPM
    //motorPulseCountA();
    pulseCountA = 0;  // Reset pulse count for Motor A

    // Calculate motor B speed in RPM
    motorSpeedReadB = (pulseCountB / pulsesPerRevolutionB) * 60.0;  // Convert to RPM
    //motorPulseCountB();
    pulseCountB = 0;  // Reset pulse count for Motor B

    // Calculate the distance traveled by each motor
    DistanceA();
    DistanceB();


    // Print motor speeds to serial monitor
    /* Serial.print("Motor A speed: ");
    Serial.print(motorSpeedReadA);
    Serial.println(" RPM");
    Serial.print("Pulse count A: ");
    Serial.println(pulseCountA);
    Serial.print("Motor A distance: ");
    Serial.print(distanceA);
    Serial.println(" m");

    Serial.print("Motor A pulse: ");
    Serial.println(pulseCountDisA);
    Serial.print("Motor B pulse: ");
    Serial.println(pulseCountDisB);

    Serial.print("Motor B speed: ");
    Serial.print(motorSpeedReadB);
    Serial.println(" RPM");
    Serial.print("Pulse count B: ");
    Serial.println(pulseCountB);
    Serial.print("Motor B distance: ");
    Serial.print(distanceB);
    Serial.println(" m");*
  }
  delay(500);
}*/
