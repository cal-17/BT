#include "mbed.h"
#include <vector>
#include <queue>
#include <limits>

#define WIDTH 7
#define HEIGHT 7

using namespace std;

struct Node {
    int x, y, cost;
    bool operator>(const Node &other) const {
        return cost > other.cost;
    }
};

// Example maze (0 = open path, 1 = wall)
int maze[HEIGHT][WIDTH] = {
    {0, 0, 0, 0, 1, 0, 0},
    {1, 1, 1, 0, 1, 0, 1},
    {0, 0, 0, 0, 0, 0, 1},
    {0, 1, 1, 1, 1, 1, 1},
    {0, 0, 0, 0, 0, 0, 0},
    {1, 1, 1, 0, 1, 1, 1},
    {0, 0, 0, 0, 0, 0, 0}
};

int dist[HEIGHT][WIDTH];
pair<int, int> prevNode[HEIGHT][WIDTH];

int dx[] = {-1, 1, 0, 0}; // Up, Down, Left, Right
int dy[] = {0, 0, -1, 1};

void dijkstra(int startX, int startY, int endX, int endY) {
    for (int i = 0; i < HEIGHT; i++) {
        for (int j = 0; j < WIDTH; j++) {
            dist[i][j] = numeric_limits<int>::max();
            prevNode[i][j] = {-1, -1};
        }
    }

    priority_queue<Node, vector<Node>, greater<Node>> pq;
    pq.push({startX, startY, 0});
    dist[startX][startY] = 0;

    while (!pq.empty()) {
        Node current = pq.top(); pq.pop();
        int x = current.x, y = current.y;

        if (x == endX && y == endY) break;

        for (int i = 0; i < 4; i++) {
            int nx = x + dx[i], ny = y + dy[i];
            if (nx >= 0 && ny >= 0 && nx < HEIGHT && ny < WIDTH && maze[nx][ny] == 0) {
                int newCost = dist[x][y] + 1;
                if (newCost < dist[nx][ny]) {
                    dist[nx][ny] = newCost;
                    prevNode[nx][ny] = {x, y};
                    pq.push({nx, ny, newCost});
                }
            }
        }
    }
}

void printMazeWithPath(int endX, int endY) {
    char displayMaze[HEIGHT][WIDTH];
    
    // Copy maze to displayMaze
    for (int i = 0; i < HEIGHT; i++) {
        for (int j = 0; j < WIDTH; j++) {
            displayMaze[i][j] = (maze[i][j] == 1) ? '#' : '.';
        }
    }

    // Mark the path
    vector<pair<int, int>> path;
    for (pair<int, int> at = {endX, endY}; at.first != -1; at = prevNode[at.first][at.second]) {
        path.push_back(at);
    }
    reverse(path.begin(), path.end());
    
    for (auto p : path) {
        displayMaze[p.first][p.second] = 'P';
    }

    // Print the maze
    Serial.println("Maze with Shortest Path:");
    for (int i = 0; i < HEIGHT; i++) {
        for (int j = 0; j < WIDTH; j++) {
            Serial.print(displayMaze[i][j]);
            Serial.print(" ");
        }
        Serial.println();
    }
}

void setup() {
    Serial.begin(9600);
    while (!Serial);
    Serial.println("Solving maze with Dijkstra's algorithm...");
}

void loop() {
    int startX = 0, startY = 0, endX = 6, endY = 6;
    dijkstra(startX, startY, endX, endY);
    printMazeWithPath(endX, endY);
    while (true); // Stop execution after running once
}




/*#include "mbed.h"
#include <vector>
#include <queue>
#include <limits>

#define WIDTH 7
#define HEIGHT 7

using namespace std;

struct Node {
    int x, y, cost;
    bool operator>(const Node &other) const {
        return cost > other.cost;
    }
};

// Example maze (0 = open path, 1 = wall)
int maze[HEIGHT][WIDTH] = {
    {0, 0, 0, 0, 1, 0, 0},
    {1, 1, 1, 0, 1, 0, 1},
    {0, 0, 0, 0, 0, 0, 1},
    {0, 1, 1, 1, 1, 1, 1},
    {0, 0, 0, 0, 0, 0, 0},
    {1, 1, 1, 0, 1, 1, 1},
    {0, 0, 0, 0, 0, 0, 0}
};

int dist[HEIGHT][WIDTH];
pair<int, int> prevNode[HEIGHT][WIDTH];

int dx[] = {-1, 1, 0, 0}; // Up, Down, Left, Right
int dy[] = {0, 0, -1, 1};

void dijkstra(int startX, int startY, int endX, int endY) {
    for (int i = 0; i < HEIGHT; i++) {
        for (int j = 0; j < WIDTH; j++) {
            dist[i][j] = numeric_limits<int>::max();
            prevNode[i][j] = {-1, -1};
        }
    }

    priority_queue<Node, vector<Node>, greater<Node>> pq;
    pq.push({startX, startY, 0});
    dist[startX][startY] = 0;

    while (!pq.empty()) {
        Node current = pq.top(); pq.pop();
        int x = current.x, y = current.y;

        if (x == endX && y == endY) break;

        for (int i = 0; i < 4; i++) {
            int nx = x + dx[i], ny = y + dy[i];
            if (nx >= 0 && ny >= 0 && nx < HEIGHT && ny < WIDTH && maze[nx][ny] == 0) {
                int newCost = dist[x][y] + 1;
                if (newCost < dist[nx][ny]) {
                    dist[nx][ny] = newCost;
                    prevNode[nx][ny] = {x, y};
                    pq.push({nx, ny, newCost});
                }
            }
        }
    }
}

void printPath(int endX, int endY) {
    vector<pair<int, int>> path;
    for (pair<int, int> at = {endX, endY}; at.first != -1; at = prevNode[at.first][at.second]) {
        path.push_back(at);
    }
    reverse(path.begin(), path.end());

    Serial.println("Shortest path:");
    for (auto p : path) {
        Serial.print("(");
        Serial.print(p.first);
        Serial.print(", ");
        Serial.print(p.second);
        Serial.print(") -> ");
    }
    Serial.println("END");
}

void setup() {
    Serial.begin(9600);
    Serial.println("Solving maze with Dijkstra's algorithm...");
     while (!Serial);
    Serial.println("Serial is working!");
}


void loop() {

    Serial.println("Hello!");
    delay(1000);
    int startX = 0, startY = 0, endX = 6, endY = 6;
    dijkstra(startX, startY, endX, endY);
    printPath(endX, endY);
    while (true); // Stop execution after running once
}
*/
