void alignFrontWithTwoSensors() {
    const float targetDistance = 0.10;      // Target distance from the wall in meters
    const float distanceTolerance = 0.01;  // Allowable error in meters (e.g., Â±1 cm)
    const float alignmentTolerance = 0.01; // Allowable error between the two sensors
    const float fastSpeed = 0.3;           // Speed for larger corrections
    const float slowSpeed = 0.1;           // Speed for fine corrections

    while (true) {
        checksensors();  // Update distance readings (ensure this updates `frontLeftDistance` and `frontRightDistance`)

        // Read distances from the two front sensors
        float frontLeftDistance = getFrontLeftSensor();   // Replace with actual function to read sensor
        float frontRightDistance = getFrontRightSensor(); // Replace with actual function to read sensor

        // Calculate average distance to the wall
        float averageDistance = (frontLeftDistance + frontRightDistance) / 2;

        // Debugging output
        Serial.print("Front Left Distance: ");
        Serial.println(frontLeftDistance);
        Serial.print("Front Right Distance: ");
        Serial.println(frontRightDistance);
        Serial.print("Average Distance: ");
        Serial.println(averageDistance);

        // Check if robot is within the target range
        if (averageDistance > targetDistance + distanceTolerance) {
            forward();  // Move forward
            motorSpeedA = fastSpeed;
            motorSpeedB = fastSpeed;
        } 
        else if (averageDistance < targetDistance - distanceTolerance) {
            reverse();  // Move backward
            motorSpeedA = fastSpeed;
            motorSpeedB = fastSpeed;
        } 
        else {
            stopMotors();  // Stop the robot
            Serial.println("Front alignment complete.");
            break;  // Exit the loop
        }

        // Check for alignment
        float sensorDifference = frontLeftDistance - frontRightDistance;

        if (abs(sensorDifference) > alignmentTolerance) {
            // If left is farther, turn slightly right
            if (sensorDifference > 0) {
                motorSpeedA = slowSpeed;  // Slow down right motor
                motorSpeedB = fastSpeed; // Speed up left motor
            } 
            // If right is farther, turn slightly left
            else {
                motorSpeedA = fastSpeed;  // Speed up right motor
                motorSpeedB = slowSpeed; // Slow down left motor
            }
        } 
        else {
            // Maintain equal motor speeds for forward/backward motion
            motorSpeedA = fastSpeed;
            motorSpeedB = fastSpeed;
        }

        equalizeMotor();  // Ensure motor speed adjustments are applied correctly

        // Debugging output
        Serial.print("Motor Speed A: ");
        Serial.println(motorSpeedA);
        Serial.print("Motor Speed B: ");
        Serial.println(motorSpeedB);

        delay(100);  // Adjust delay to balance precision and responsiveness
    }
}
